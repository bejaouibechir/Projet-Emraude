# ManualResetEvent vs AutoResetEvent

Nous allons maintenant présenter les classes **`ManualResetEvent`** et **`AutoResetEvent`**, qui sont des mécanismes de synchronisation utilisés pour signaler à un ou plusieurs threads d'attendre jusqu'à ce qu'un autre thread émette un signal. 

Ces classes sont utiles pour gérer la coordination entre threads.

``` mermaid
    graph TD
        A[Thread principal] --> B[Signal d'attente-WaitOne]
        B --> C1{ManualResetEvent}
        B --> C2{AutoResetEvent}
    
        C1 --> D1[Un ou plusieurs threads attendent le signal]
        D1 --> E1[Signal envoyé-Set]
        E1 --> F1[Tous les threads en attente continuent]
        F1 --> G1[Événement reste signalé]
        G1 --> H1[Réinitialisation manuelle requise-Reset]
    
        C2 --> D2[Un ou plusieurs threads attendent le signal]
        D2 --> E2[Signal envoyé-Set]
        E2 --> F2[Un seul thread continue]
        F2 --> G2[Réinitialisation automatique à non-signalé]

```

### 1. **ManualResetEvent**

#### 1. Définition
Un **`ManualResetEvent`** est un mécanisme de synchronisation qui **reste ouvert** (signalé) une fois qu'il a été activé jusqu'à ce qu'il soit explicitement réinitialisé. Il est souvent utilisé pour permettre à plusieurs threads d'attendre un signal, et lorsqu'il est déclenché, tous les threads en attente peuvent continuer.

#### 2. États de `ManualResetEvent`
```mermaid
graph TD
    A[Initialisé à non-signalé] --> B[Thread attend-WaitOne]
    B --> C{Signal reçu ?}
    C --> D[Non] --> B
    C --> E[Oui] --> F[Thread continue l'exécution]
    F --> G[Événement reste signalé]
    G --> H[Manuel : Réinitialisation-Reset]
```

- Initialisé à un état **non-signalé** (les threads doivent attendre).
- Lorsqu'il est **signalé**, tous les threads en attente continuent leur exécution.
- Il reste en état **signalé** jusqu'à ce qu'il soit explicitement **réinitialisé**.

#### 3. Membres importants (énumération)
- **`WaitOne()`** : Met le thread en attente jusqu'à ce que l'événement soit signalé.
- **`Set()`** : Signale l'événement, permettant à tous les threads en attente de continuer.
- **`Reset()`** : Réinitialise l'événement à non-signalé, forçant les threads à attendre à nouveau.
- **`ManualResetEvent(bool initialState)`** : Initialise l'événement avec l'état signalé ou non.

#### 4. Membres importants (implémentation simple)
```csharp
ManualResetEvent manualEvent = new ManualResetEvent(false);

void WorkerMethod()
{
    Console.WriteLine("En attente du signal...");
    manualEvent.WaitOne();  // Attendre le signal
    Console.WriteLine("Signal reçu, continuation de l'exécution.");
}
```

#### 5. Exemple de synthèse
```csharp
class Program
{
    static ManualResetEvent manualEvent = new ManualResetEvent(false);

    static void Main(string[] args)
    {
        Task[] tasks = new Task[3];

        // Démarrage de plusieurs threads qui attendent un signal
        for (int i = 0; i < 3; i++)
        {
            tasks[i] = Task.Run(() =>
            {
                Console.WriteLine($"Tâche {Task.CurrentId} en attente du signal.");
                manualEvent.WaitOne();
                Console.WriteLine($"Tâche {Task.CurrentId} reprend après le signal.");
            });
        }

        // Simuler une tâche principale qui attend avant de signaler
        Thread.Sleep(2000);
        Console.WriteLine("Signal envoyé, toutes les tâches vont reprendre.");
        manualEvent.Set();  // Signal

        Task.WaitAll(tasks);
    }
}
```

#### 6. Limites de `ManualResetEvent`
- **Manuel** : Vous devez explicitement appeler **`Reset()`** pour renvoyer l'événement à l'état non-signalé. Cela peut conduire à des erreurs si vous oubliez de le réinitialiser.
- **Tous les threads sont libérés en même temps** : Si plusieurs threads attendent sur un `ManualResetEvent`, tous seront libérés lorsque l'événement sera signalé.

---

### 2. **AutoResetEvent**

#### 1. Définition
Un **`AutoResetEvent`** est similaire à un `ManualResetEvent`, mais avec une différence clé : il **se réinitialise automatiquement** à l'état non-signalé après avoir libéré un thread. Cela signifie qu'il ne libère qu'**un seul thread** à la fois.

#### 2. États de `AutoResetEvent`
```mermaid
graph TD
    A[Initialisé à non-signalé] --> B[Thread attend-WaitOne]
    B --> C{Signal reçu ?}
    C --> D[Non] --> B
    C --> E[Oui] --> F[Libère un thread]
    F --> G[Réinitialisation automatique à non-signalé]
    G --> B
```

- Initialisé à un état **non-signalé**, les threads attendent.
- Lorsqu'il est **signalé**, **un seul thread** continue son exécution.
- Il est automatiquement réinitialisé à **non-signalé** après avoir libéré un thread.

#### 3. Membres importants (énumération)
- **`WaitOne()`** : Met le thread en attente jusqu'à ce que l'événement soit signalé.
- **`Set()`** : Signale l'événement, permettant à un seul thread en attente de continuer.
- **`AutoResetEvent(bool initialState)`** : Initialise l'événement avec l'état signalé ou non.

#### 4. Membres importants (implémentation simple)
```csharp
AutoResetEvent autoEvent = new AutoResetEvent(false);

void WorkerMethod()
{
    Console.WriteLine("En attente du signal...");
    autoEvent.WaitOne();  // Attendre le signal
    Console.WriteLine("Signal reçu, continuation de l'exécution.");
}
```

#### 5. Exemple de synthèse
```csharp
class Program
{
    static AutoResetEvent autoEvent = new AutoResetEvent(false);

    static void Main(string[] args)
    {
        Task[] tasks = new Task[3];

        // Démarrage de plusieurs threads qui attendent un signal
        for (int i = 0; i < 3; i++)
        {
            tasks[i] = Task.Run(() =>
            {
                Console.WriteLine($"Tâche {Task.CurrentId} en attente du signal.");
                autoEvent.WaitOne();
                Console.WriteLine($"Tâche {Task.CurrentId} reprend après le signal.");
            });
        }

        // Simuler une tâche principale qui envoie plusieurs signaux
        for (int i = 0; i < 3; i++)
        {
            Thread.Sleep(1000);
            Console.WriteLine("Signal envoyé, une tâche va reprendre.");
            autoEvent.Set();  // Signal
        }

        Task.WaitAll(tasks);
    }
}
```

#### 6. Limites de `AutoResetEvent`
- **Libère un seul thread à la fois** : Contrairement à `ManualResetEvent`, seulement **un thread** est libéré par appel à **`Set()`**.
- **Moins de contrôle** : Si vous avez besoin de libérer plusieurs threads en même temps, il est préférable d'utiliser `ManualResetEvent`.

---

### Comparaison rapide entre `ManualResetEvent` et `AutoResetEvent`

| Fonctionnalité                   | **`ManualResetEvent`**               | **`AutoResetEvent`**                |
|-----------------------------------|--------------------------------------|-------------------------------------|
| **Signalisation**                 | Libère tous les threads en attente   | Libère un seul thread en attente    |
| **Réinitialisation**              | Manuelle avec `Reset()`              | Automatique après la libération     |
| **Scénarios d'utilisation**       | Libération simultanée de plusieurs threads | Libération d'un thread à la fois    |
| **Utilisation typique**           | Coordination de plusieurs threads    | Synchronisation fine entre deux threads |

---

### Conclusion

**`ManualResetEvent`** et **`AutoResetEvent`** sont des mécanismes de synchronisation utiles pour contrôler les signaux entre threads :

- Utilisez **`ManualResetEvent`** si vous avez besoin de libérer **plusieurs threads** simultanément et que vous souhaitez un contrôle manuel sur la réinitialisation de l'événement.
- Utilisez **`AutoResetEvent`** lorsque vous avez besoin de libérer **un thread à la fois** et que vous préférez une réinitialisation automatique après chaque signal.

Ces mécanismes offrent des solutions pratiques pour coordonner le travail entre plusieurs threads, bien que **`ManualResetEvent`** offre plus de contrôle manuel, tandis que **`AutoResetEvent`** est plus automatisé pour des scénarios simples de synchronisation.
