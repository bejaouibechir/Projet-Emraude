# Eager, Lazy et Explicit avec Entity Framework

En Entity Framework (EF), les stratégies de chargement des données associées sont cruciales pour gérer les relations entre les entités. Voici une explication des trois principales stratégies : **Eager Loading**, **Lazy Loading**, et **Explicit Loading**.

### 1. **Eager Loading (Chargement hâtif)**
Le **Eager Loading** consiste à charger les données associées en même temps que l'entité principale, au moment où la requête est exécutée. Cela se fait en utilisant la méthode `Include` dans Entity Framework. Cette stratégie est utile lorsque vous savez à l'avance que vous aurez besoin des données associées, car elle permet de réduire le nombre de requêtes envoyées à la base de données.

**Exemple :**
```csharp
var orders = context.Orders
                    .Include(o => o.Customer)
                    .ToList();
```
Dans cet exemple, les commandes (`Orders`) sont chargées avec les informations des clients (`Customer`) en une seule requête.

**Avantages :**
- Réduit le nombre de requêtes envoyées à la base de données (souvent appelé le problème N+1).
- Utile lorsque les données associées sont nécessaires immédiatement.

**Inconvénients :**
- Peut entraîner le chargement de données non nécessaires, augmentant ainsi l'utilisation de la mémoire et le temps de traitement.

### 2. **Lazy Loading (Chargement paresseux)**
Le **Lazy Loading** retarde le chargement des données associées jusqu'à ce qu'elles soient explicitement accédées pour la première fois. En EF, cela se fait généralement en marquant les propriétés de navigation comme `virtual`, permettant à EF de créer des proxies dynamiques pour charger les données à la demande.

**Exemple :**
```csharp
public class Order
{
    public int OrderId { get; set; }
    public virtual Customer Customer { get; set; }
}

var order = context.Orders.FirstOrDefault(o => o.OrderId == 1);
var customer = order.Customer; // Customer is loaded here, not earlier
```
Ici, les informations sur le client (`Customer`) ne seront chargées que lorsque la propriété `Customer` sera accédée.

**Avantages :**
- Économise de la mémoire en ne chargeant pas les données tant qu'elles ne sont pas nécessaires.
- Permet un chargement plus rapide des entités principales.

**Inconvénients :**
- Peut entraîner plusieurs requêtes à la base de données, ce qui peut être inefficace (problème N+1).
- Moins performant si les données associées sont fréquemment nécessaires.

### 3. **Explicit Loading (Chargement explicite)**
Le **Explicit Loading** est similaire au Lazy Loading en ce qu'il ne charge pas automatiquement les données associées, mais diffère en ce qu'il nécessite que le chargement des données soit déclenché manuellement par le développeur. Cela se fait en utilisant la méthode `Load` de Entity Framework.

**Exemple :**
```csharp
var order = context.Orders.FirstOrDefault(o => o.OrderId == 1);
context.Entry(order).Reference(o => o.Customer).Load();
```
Dans cet exemple, l'entité `Customer` est explicitement chargée après que l'entité `Order` a été récupérée.

**Avantages :**
- Donne un contrôle total au développeur sur le moment et les données à charger.
- Évite les requêtes supplémentaires automatiques non désirées.

**Inconvénients :**
- Nécessite plus de code et de gestion manuelle pour assurer le bon chargement des données.

### Quand utiliser chaque stratégie ?

- **Eager Loading** : Utilisez-le lorsque vous savez que vous avez besoin des données associées avec l'entité principale.
- **Lazy Loading** : Idéal pour les scénarios où vous n'avez pas toujours besoin des données associées, mais que vous voulez les charger automatiquement lorsqu'elles sont accédées.
- **Explicit Loading** : Utilisez-le lorsque vous souhaitez contrôler manuellement le chargement des données associées, souvent pour optimiser les performances dans des scénarios complexes.
