# Accès aux données avec EF Core

### Accès aux données avec EF Core : Guide Complet

#### 1. **Bibliothèques nécessaires pour différents SGBD**

Pour utiliser Entity Framework Core avec différents systèmes de gestion de bases de données (SGBD), vous devez installer les bibliothèques suivantes via NuGet :

- **SQL Server** :
  ```bash
  dotnet add package Microsoft.EntityFrameworkCore.SqlServer
  ```

- **PostgreSQL** :
  ```bash
  dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL
  ```

- **MySQL** :
  ```bash
  dotnet add package Pomelo.EntityFrameworkCore.MySql
  ```

- **Bibliothèques supplémentaires** :
  - **Microsoft.EntityFrameworkCore.Design** : Nécessaire pour les outils de migration et autres fonctionnalités de design.
    ```bash
    dotnet add package Microsoft.EntityFrameworkCore.Design
    ```
  - **Microsoft.EntityFrameworkCore.Tools** : Nécessaire pour utiliser l'outil `dotnet ef` en ligne de commande.
    ```bash
    dotnet add package Microsoft.EntityFrameworkCore.Tools
    ```

#### 2. **L'outil Global `dotnet ef`**

`dotnet ef` est un outil en ligne de commande utilisé pour interagir avec Entity Framework Core. Cet outil est indispensable pour gérer les migrations, générer des scripts SQL, et bien plus encore. Pour l'installer globalement :
```bash
dotnet tool install --global dotnet-ef
```

#### 3. **Commandes `dotnet ef migrations`**

Les commandes `dotnet ef migrations` permettent de gérer l'évolution de votre schéma de base de données. Voici quelques commandes essentielles :

- **add** : Ajoute une nouvelle migration basée sur les changements du modèle.
  ```bash
  dotnet ef migrations add InitialCreate
  ```

- **remove** : Supprime la dernière migration ajoutée.
  ```bash
  dotnet ef migrations remove
  ```

- **script** : Génère un script SQL basé sur une migration spécifique ou l'ensemble des migrations.
  ```bash
  dotnet ef migrations script
  ```

- **list** : Liste toutes les migrations appliquées ou non.
  ```bash
  dotnet ef migrations list
  ```

- **bundle** : Crée un exécutable autonome pour appliquer les migrations.
  ```bash
  dotnet ef migrations bundle
  ```

- **has-pending-model-changes** : Vérifie si le modèle a des changements non migrés.
  ```bash
  dotnet ef migrations has-pending-model-changes
  ```

#### 4. **Comparaison des approches : Database First vs Code First**

- **Database First** : Cette approche consiste à générer des classes `DbContext` et modèles à partir d'une base de données existante. Elle est idéale lorsque la base de données est déjà en place.
  ```bash
  dotnet ef dbcontext scaffold "YourConnectionString" Microsoft.EntityFrameworkCore.SqlServer -o Models
  ```

- **Code First** : Vous commencez par créer les classes de modèle en C#, puis EF Core génère la base de données. Cette approche est plus flexible si vous commencez un nouveau projet.
  ```csharp
  public class ApplicationDbContext : DbContext
  {
      public DbSet<Product> Products { get; set; }

      protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
      {
          optionsBuilder.UseSqlServer("YourConnectionString");
      }
  }

  public class Product
  {
      public int Id { get; set; }
      public string Name { get; set; }
      public decimal Price { get; set; }
  }
  ```

  Pour générer la base de données :
  ```bash
  dotnet ef migrations add InitialCreate
  dotnet ef database update
  ```

#### 5. **La classe DbContext**

La classe `DbContext` est le cœur d'EF Core. Elle représente une session avec la base de données et permet de manipuler les données via des entités.

```csharp
public class ApplicationDbContext : DbContext
{
    public DbSet<Customer> Customers { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer("YourConnectionString");
    }
}
```

#### 6. **Fluent API vs Annotations**

- **Annotations** : Les annotations sont intégrées directement dans les classes de modèles. Elles sont simples à utiliser mais offrent des possibilités limitées.
  ```csharp
  public class Product
  {
      [Key]
      public int Id { get; set; }

      [Required]
      public string Name { get; set; }
  }
  ```

- **Fluent API** : Fluent API offre une plus grande flexibilité pour configurer les entités, notamment pour des configurations complexes comme les clés composées ou les relations multiples.
  ```csharp
  protected override void OnModelCreating(ModelBuilder modelBuilder)
  {
      modelBuilder.Entity<Product>()
          .HasKey(p => p.Id);

      modelBuilder.Entity<Product>()
          .Property(p => p.Name)
          .IsRequired();
  }
  ```

  **Limitation des annotations** : Les annotations ne permettent pas de configurer des aspects avancés comme les relations complexes, les clés composées ou les types de données spécifiques. Fluent API est souvent nécessaire pour ces scénarios.

#### 7. **Implémentation directe vs Configurations dans `OnModelCreating`**

- **Implémentation directe dans `OnModelCreating`** : Les configurations peuvent être directement définies dans la méthode `OnModelCreating`, ce qui est pratique pour les petits projets ou les configurations simples.
  ```csharp
  modelBuilder.Entity<Order>()
      .HasOne(o => o.Customer)
      .WithMany(c => c.Orders)
      .HasForeignKey(o => o.CustomerId);
  ```

- **Configurations via classes séparées** : Pour les projets plus complexes, il est recommandé d'utiliser des classes de configuration séparées, implémentant `IEntityTypeConfiguration<T>`. Cela permet une meilleure organisation et maintenabilité du code.
  ```csharp
  public class OrderConfiguration : IEntityTypeConfiguration<Order>
  {
      public void Configure(EntityTypeBuilder<Order> builder)
      {
          builder.HasOne(o => o.Customer)
                 .WithMany(c => c.Orders)
                 .HasForeignKey(o => o.CustomerId);
      }
  }

  protected override void OnModelCreating(ModelBuilder modelBuilder)
  {
      modelBuilder.ApplyConfiguration(new OrderConfiguration());
  }
  ```

Cette approche permet de centraliser la logique de configuration, rendant le code plus propre et plus facile à maintenir, surtout dans les grands projets. 

# Cas pratique 

[Ce tutoriel montre comment créer une application CRUD Oracle](https://github.com/bejaouibechir/CSharpLevel2/blob/J4/Cr%C3%A9er%20un%20microservice%20avec%20une%20base%20de%20donn%C3%A9es%20SQLORACLE.md)
