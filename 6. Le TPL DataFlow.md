# Le TPL DataFlow

Le **TPL Dataflow** de .NET propose en effet plusieurs autres types de blocs en plus de ceux que nous avons abordés.

Voici une liste plus complète des **blocks disponibles** dans le cadre de la **TPL Dataflow**, avec une brève définition pour chacun :

### Principaux Blocks dans TPL Dataflow

### 1. **BufferBlock<T>**  
Le `BufferBlock<T>` stocke des messages jusqu'à ce qu'ils soient consommés. C'est une sorte de file d'attente.

```csharp
using System;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

class Program
{
    static async Task Main()
    {
        var bufferBlock = new BufferBlock<int>();

        // Envoyer des données dans le buffer
        await bufferBlock.SendAsync(1);
        await bufferBlock.SendAsync(2);
        await bufferBlock.SendAsync(3);

        // Recevoir les données
        Console.WriteLine(await bufferBlock.ReceiveAsync()); // 1
        Console.WriteLine(await bufferBlock.ReceiveAsync()); // 2
        Console.WriteLine(await bufferBlock.ReceiveAsync()); // 3
    }
}
```

### 2. **BroadcastBlock<T>**  
Le `BroadcastBlock<T>` envoie une copie du même message à plusieurs récepteurs.

```csharp
using System;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

class Program
{
    static void Main()
    {
        var broadcastBlock = new BroadcastBlock<int>(null);

        // Lier deux blocs de réception
        var target1 = new ActionBlock<int>(n => Console.WriteLine($"Target 1: {n}"));
        var target2 = new ActionBlock<int>(n => Console.WriteLine($"Target 2: {n}"));

        broadcastBlock.LinkTo(target1);
        broadcastBlock.LinkTo(target2);

        // Envoyer un message
        broadcastBlock.Post(42);  // Les deux récepteurs recevront 42

        // Attendre que les actions soient terminées
        target1.Completion.Wait();
        target2.Completion.Wait();
    }
}
```

### 3. **TransformBlock<TInput, TOutput>**  
Le `TransformBlock<TInput, TOutput>` applique une fonction de transformation aux données reçues.

```csharp
using System;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

class Program
{
    static async Task Main()
    {
        var transformBlock = new TransformBlock<int, int>(n => n * 2);

        // Envoyer des données
        await transformBlock.SendAsync(5);

        // Recevoir la transformation
        Console.WriteLine(await transformBlock.ReceiveAsync()); // 10
    }
}
```

### 4. **TransformManyBlock<TInput, TOutput>**  
Le `TransformManyBlock<TInput, TOutput>` génère plusieurs sorties pour une seule entrée.

```csharp
using System;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;
using System.Linq;

class Program
{
    static async Task Main()
    {
        var transformManyBlock = new TransformManyBlock<int, int>(n => Enumerable.Range(1, n));

        // Envoyer des données
        await transformManyBlock.SendAsync(3);

        // Recevoir plusieurs résultats
        for (int i = 0; i < 3; i++)
        {
            Console.WriteLine(await transformManyBlock.ReceiveAsync()); // 1, 2, 3
        }
    }
}
```

### 5. **ActionBlock<T>**  
Le `ActionBlock<T>` effectue une action sans renvoyer de résultat. C’est souvent utilisé pour des tâches finales, comme l’affichage ou la persistance.

```csharp
using System;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

class Program
{
    static async Task Main()
    {
        var actionBlock = new ActionBlock<int>(n => Console.WriteLine($"Processing: {n}"));

        // Envoyer des données
        await actionBlock.SendAsync(5);
        await actionBlock.SendAsync(10);

        // Attendre la fin du traitement
        actionBlock.Complete();
        await actionBlock.Completion;
    }
}
```

### 6. **JoinBlock<T1, T2>**  
Le `JoinBlock<T1, T2>` combine deux flux de données pour former des paires.

```csharp
using System;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

class Program
{
    static async Task Main()
    {
        var joinBlock = new JoinBlock<int, string>();

        // Envoyer des données dans les deux flux
        await joinBlock.Target1.SendAsync(42);
        await joinBlock.Target2.SendAsync("Hello");

        // Recevoir la paire combinée
        var result = await joinBlock.ReceiveAsync();
        Console.WriteLine($"{result.Item1}, {result.Item2}"); // 42, Hello
    }
}
```

### 7. **BatchBlock<T>**  
Le `BatchBlock<T>` regroupe plusieurs messages dans un tableau, les envoyant en un seul lot lorsque le nombre de messages atteint la taille spécifiée.

```csharp
using System;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

class Program
{
    static async Task Main()
    {
        var batchBlock = new BatchBlock<int>(3); // Groupe par 3 éléments

        // Envoyer des données
        await batchBlock.SendAsync(1);
        await batchBlock.SendAsync(2);
        await batchBlock.SendAsync(3);

        // Recevoir le lot
        var batch = await batchBlock.ReceiveAsync();
        Console.WriteLine(string.Join(", ", batch)); // 1, 2, 3
    }
}
```

### 8. **WriteOnceBlock<T>**  
Le `WriteOnceBlock<T>` ne prend qu'une seule valeur et l'envoie à plusieurs récepteurs. Une fois cette valeur fixée, elle ne peut plus être modifiée.

```csharp
using System;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

class Program
{
    static void Main()
    {
        var writeOnceBlock = new WriteOnceBlock<int>(n => n);

        // Envoyer une seule valeur
        writeOnceBlock.Post(100);

        // Recevoir cette valeur à plusieurs reprises
        Console.WriteLine(writeOnceBlock.Receive()); // 100
        Console.WriteLine(writeOnceBlock.Receive()); // 100
    }
}
```

### 9. **JoinBlock<T1, T2, T3>**  
Le `JoinBlock<T1, T2, T3>` fonctionne comme le `JoinBlock<T1, T2>`, mais avec trois flux de données.

```csharp
using System;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

class Program
{
    static async Task Main()
    {
        var joinBlock = new JoinBlock<int, string, bool>();

        // Envoyer des données dans les trois flux
        await joinBlock.Target1.SendAsync(99);
        await joinBlock.Target2.SendAsync("World");
        await joinBlock.Target3.SendAsync(true);

        // Recevoir la triplette combinée
        var result = await joinBlock.ReceiveAsync();
        Console.WriteLine($"{result.Item1}, {result.Item2}, {result.Item3}"); // 99, World, True
    }
}
```


Ces exemples couvrent l'essentiel des **blocs TPL Dataflow** utilisés dans le traitement parallèle et le flux de données en .NET. Ils montrent comment traiter des données de manière concurrente et asynchrone dans des pipelines de traitement clair et modulaire.
### 10. Exemple simple : Utilisation de plusieurs blocs

Voici un exemple qui utilise plusieurs blocs pour illustrer un pipeline de données plus complexe. Ce pipeline reçoit des nombres, les double, les incrémente, puis les affiche en batch :

```csharp
using System;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

class Program
{
    static async Task Main()
    {
        // Créer les blocs
        var bufferBlock = new BufferBlock<int>();
        var doubleBlock = new TransformBlock<int, int>(n => n * 2);
        var incrementBlock = new TransformBlock<int, int>(n => n + 1);
        var batchBlock = new BatchBlock<int>(3);
        var actionBlock = new ActionBlock<int[]>(numbers =>
        {
            Console.WriteLine("Batch received: " + string.Join(", ", numbers));
        });

        // Lier les blocs
        bufferBlock.LinkTo(doubleBlock);
        doubleBlock.LinkTo(incrementBlock);
        incrementBlock.LinkTo(batchBlock);
        batchBlock.LinkTo(actionBlock);

        // Envoyer des données dans le pipeline
        for (int i = 1; i <= 9; i++)
        {
            await bufferBlock.SendAsync(i);
        }

        // Terminer les blocs
        bufferBlock.Complete();
        await actionBlock.Completion;
    }
}
```

### Explication de cet exemple :

1. **BufferBlock<int>** : Ce bloc stocke les nombres envoyés avant leur traitement.
2. **TransformBlock<int, int>** : Deux blocs de transformation sont utilisés. Le premier double les nombres, et le second les incrémente de 1.
3. **BatchBlock<int>** : Ce bloc groupe les résultats en lots de 3 avant de les envoyer au bloc suivant.
4. **ActionBlock<int[]>** : Ce bloc affiche le résultat final de chaque batch.

### 11. Synthèse plus complexe

Pour un exemple plus avancé, imaginons un pipeline qui regroupe plusieurs transformations, comme du traitement de texte. Le texte passe par plusieurs transformations avant d'être stocké :

```csharp
using System;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

class Program
{
    static async Task Main()
    {
        var inputBlock = new BufferBlock<string>();
        var toUpperBlock = new TransformBlock<string, string>(s => s.ToUpper());
        var replaceBlock = new TransformBlock<string, string>(s => s.Replace("HELLO", "HI"));
        var batchBlock = new BatchBlock<string>(3);
        var actionBlock = new ActionBlock<string[]>(texts =>
        {
            Console.WriteLine("Batch processed: " + string.Join(", ", texts));
        });

        // Linking the blocks together
        inputBlock.LinkTo(toUpperBlock);
        toUpperBlock.LinkTo(replaceBlock);
        replaceBlock.LinkTo(batchBlock);
        batchBlock.LinkTo(actionBlock);

        // Sending data to the pipeline
        string[] texts = { "hello world", "hello TPL", "hello async", "dataflow rocks", "hello blocks", "TPL rocks" };
        foreach (var text in texts)
        {
            await inputBlock.SendAsync(text);
        }

        // Complete the pipeline
        inputBlock.Complete();
        await actionBlock.Completion;
    }
}
```

### Explication :

- **Transformations** : Le texte est d'abord converti en majuscules, puis on remplace tous les "HELLO" par "HI".
- **Batching** : Les résultats sont regroupés par lots de 3 avant d'être traités.
- **Action finale** : Affiche les résultats de chaque lot après traitement.

Cet exemple illustre comment une série de transformations peut être enchaînée dans un pipeline de données complexe, en gérant plusieurs étapes simultanées et en maximisant l'efficacité des opérations.
