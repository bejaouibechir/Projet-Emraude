# Créer une Web API en .NET 8.0 avec PostgreSQL Conteneurisé

### Étape 1 : Créer un Nouveau Projet Web API en .NET 8.0

1. Ouvrez un terminal et créez un nouveau projet Web API :
   ```bash
   dotnet new webapi -n PostgresApi
   cd PostgresApi
   ```

2. Installez le package NuGet pour PostgreSQL et Entity Framework Core :
   ```bash
   dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL
   ```

### Étape 2 : Définir le Modèle `Product`

1. Créez un modèle C# correspondant à la table `products` dans la base de données PostgreSQL :

   ```csharp
   using System.ComponentModel.DataAnnotations;
   using System.ComponentModel.DataAnnotations.Schema;

   namespace PostgresApi.Models
   {
       [Table("products")]
       public class Product
       {
           [Key]
           [Column("id")]
           public int Id { get; set; }

           [Column("name")]
           public string Name { get; set; }

           [Column("price")]
           public decimal Price { get; set; }
       }
   }
   ```

### Étape 3 : Configurer le `DbContext`

1. Créez un `DbContext` pour interagir avec PostgreSQL :

   ```csharp
   using Microsoft.EntityFrameworkCore;
   using PostgresApi.Models;

   namespace PostgresApi.Data
   {
       public class AppDbContext : DbContext
       {
           public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }

           public DbSet<Product> Products { get; set; }
       }
   }
   ```

2. Configurez le contexte dans `Program.cs` :

   ```csharp
   var builder = WebApplication.CreateBuilder(args);

   // Ajouter les services au conteneur.
   builder.Services.AddControllers();
   builder.Services.AddDbContext<AppDbContext>(options =>
       options.UseNpgsql(builder.Configuration.GetConnectionString("PostgresConnection")));

   // Configuration des routes de l'API
   builder.Services.AddEndpointsApiExplorer();
   builder.Services.AddSwaggerGen();

   var app = builder.Build();

   // Activer la documentation Swagger
   if (app.Environment.IsDevelopment())
   {
       app.UseSwagger();
       app.UseSwaggerUI();
   }

   app.UseHttpsRedirection();

   app.UseAuthorization();

   app.MapControllers();

   app.Run();
   ```

3. Ajoutez la chaîne de connexion à `appsettings.json` :

   ```json
   {
     "ConnectionStrings": {
       "PostgresConnection": "Host=postgresapi-postgres_container-1;Database=postgres;Username=postgres;Password=test123++"
     },
     "Logging": {
       "LogLevel": {
         "Default": "Information",
         "Microsoft.AspNetCore": "Warning"
       }
     },
     "AllowedHosts": "*"
   }
   ```

### Étape 4 : Créer le Fichier `init.sql` pour Initialiser la Base de Données

1. Créez un fichier `init.sql` à la racine du projet pour créer la table `products` :

   ```sql
   CREATE TABLE IF NOT EXISTS products (
       id SERIAL PRIMARY KEY,
       name VARCHAR(100),
       price DECIMAL(10, 2)
   );
   ```

### Étape 5 : Configurer Docker et Docker Compose

1. Créez un `Dockerfile` pour votre Web API :

   ```dockerfile
   # Utilisez l'image SDK de .NET qui contient tous les outils de développement nécessaires
   FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
   WORKDIR /app

   # Copiez tout le contenu et restaurez les dépendances
   COPY . .
   RUN dotnet restore

   # Installez l'outil dotnet-ef globalement
   RUN dotnet tool install --global dotnet-ef

   # Ajoutez le chemin des outils dotnet au PATH
   ENV PATH="$PATH:/root/.dotnet/tools"

   # Construisez l'application
   RUN dotnet build -c Release
   RUN dotnet publish -c Release -o out

   # Utilisez l'image runtime de .NET pour exécuter l'application
   FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS runtime
   WORKDIR /app
   COPY --from=build /app/out .

   # Exposez le port
   EXPOSE 8080

   ENTRYPOINT ["dotnet", "PostgresApi.dll"]
   ```

2. Créez un fichier `docker-compose.yml` pour orchestrer les conteneurs :

   ```yaml
   version: '3.9'

   services:
     postgres_container:
       image: postgres:latest
       environment:
         POSTGRES_DB: postgres
         POSTGRES_USER: postgres
         POSTGRES_PASSWORD: test123++
       volumes:
         - postgres_data:/var/lib/postgresql/data
         - ./init.sql:/docker-entrypoint-initdb.d/init.sql
       ports:
         - "5432:5432"
       networks:
         - postgres_network

     webapi_container:
       build: .
       depends_on:
         - postgres_container
       networks:
         - postgres_network
       ports:
         - "5000:8080"  # Expose le port 8080 du conteneur sur le port 5000 de l'hôte

   networks:
     postgres_network:

   volumes:
     postgres_data:
   ```

### Étape 6 : Configurer `launchSettings.json`

1. Configurez le fichier `launchSettings.json` pour inclure le profil Docker :

   ```json
   {
     "profiles": {
       "http": {
         "commandName": "Project",
         "launchBrowser": true,
         "launchUrl": "swagger",
         "environmentVariables": {
           "ASPNETCORE_ENVIRONMENT": "Development"
         },
         "dotnetRunMessages": true,
         "applicationUrl": "http://localhost:5153"
       },
       "https": {
         "commandName": "Project",
         "launchBrowser": true,
         "launchUrl": "swagger",
         "environmentVariables": {
           "ASPNETCORE_ENVIRONMENT": "Development"
         },
         "dotnetRunMessages": true,
         "applicationUrl": "https://localhost:7229;http://localhost:5153"
       },
       "IIS Express": {
         "commandName": "IISExpress",
         "launchBrowser": true,
         "launchUrl": "swagger",
         "environmentVariables": {
           "ASPNETCORE_ENVIRONMENT": "Development"
         }
       },
       "Container (Dockerfile)": {
         "commandName": "Docker",
         "launchBrowser": true,
         "launchUrl": "http://localhost:5000/swagger",
         "environmentVariables": {
           "ASPNETCORE_HTTPS_PORTS": "5001",
           "ASPNETCORE_HTTP_PORTS": "5000"
         },
         "publishAllPorts": true,
         "useSSL": true
       }
     },
     "$schema": "http://json.schemastore.org/launchsettings.json",
     "iisSettings": {
       "windowsAuthentication": false,
       "anonymousAuthentication": true,
       "iisExpress": {
         "applicationUrl": "http://localhost:49356",
         "sslPort": 44320
       }
     }
   }
   ```

### Étape 7 : Démarrer les Conteneurs et Vérifier

1. Construisez et démarrez les conteneurs :

   ```bash
   docker-compose up --build
   ```

2. Vérifiez les logs des conteneurs pour s'assurer que tout démarre correctement :

   ```bash
   docker logs webapi_container
   ```

3. Testez l'API en accédant à `http://localhost:5000/api/products` dans votre navigateur ou via un outil comme Postman.

### Conclusion

- **Organisation et Orchestration** : Nous avons utilisé `docker-compose` pour orchestrer les conteneurs Web API et PostgreSQL, assurant ainsi une configuration propre et reproductible.
- **Sensibilité à la Casse** : Nous avons fait attention à la casse des noms des tables et des colonnes pour éviter des erreurs de mapping entre les entités C# et les tables PostgreSQL.
- **Initialisation Automatique de la Base de Données** : La table `products` a été créée automatiquement via un script SQL exécuté lors du démarrage du conteneur PostgreSQL, éliminant ainsi le besoin de migrations manuelles dans ce contexte.
- **Gestion Correcte des Chaînes de Connexion** : Nous avons utilisé le nom du conteneur PostgreSQL dans la chaîne de connexion pour assurer la communication correcte entre les conteneurs.
- **Tests Itératifs** : Nous avons testé l'API à chaque étape pour valider les configurations et nous assurer que chaque composant fonctionnait comme prévu.

En suivant ces bonnes pratiques, vous avez construit une application Web API robuste et bien structurée, prête à être déployée ou étendue avec d'autres fonctionnalités.
