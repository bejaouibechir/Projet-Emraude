# Repenser les données

Lorsque vous migrez d'une **architecture monolithique** vers une **architecture microservices**, vous devez décider comment gérer les données. Deux approches courantes sont :

1. **Utiliser une base de données unique avec des schémas distincts pour chaque microservice**.

``` mermaid
  graph TD
      subgraph Database
          DB[Base de Données Unique]
      end
  
      subgraph Microservice1
          MS1[Microservice 1]
          MS1 -->|Accès| DB
          DB -->|Schéma 1| DBSchema1[Schéma 1]
      end
  
      subgraph Microservice2
          MS2[Microservice 2]
          MS2 -->|Accès| DB
          DB -->|Schéma 2| DBSchema2[Schéma 2]
      end
  
      subgraph Microservice3
          MS3[Microservice 3]
          MS3 -->|Accès| DB
          DB -->|Schéma 3| DBSchema3[Schéma 3]
      end
  
      DB -->|Schéma N| DBSchemaN[Schéma N]

```
   
2. **Faire du sharding de la base de données initiale en plusieurs bases de données pour chaque microservice**.

``` mermaid
graph TD
    subgraph Database Shards
        DBS1[Base de Données Shard 1]
        DBS2[Base de Données Shard 2]
        DBS3[Base de Données Shard 3]
        DBS4[Base de Données Shard 4]
    end

    subgraph Microservice1
        MS1[Microservice 1]
        MS1 -->|Accès| DBS1
        MS1 -->|Accès| DBS2
    end

    subgraph Microservice2
        MS2[Microservice 2]
        MS2 -->|Accès| DBS2
        MS2 -->|Accès| DBS3
    end

    subgraph Microservice3
        MS3[Microservice 3]
        MS3 -->|Accès| DBS3
        MS3 -->|Accès| DBS4
    end

    subgraph Microservice4
        MS4[Microservice 4]
        MS4 -->|Accès| DBS4
        MS4 -->|Accès| DBS1
    end

```
    


Voici une comparaison entre ces deux approches :

<table>
  <td>
   Base de Données Unique avec Schémas Distincts
    
**Avantages :**
- **Simplicité de gestion** : Une seule base de données à gérer, ce qui peut simplifier les opérations de sauvegarde, de restauration et de mise à jour.
- **Consistance transactionnelle** : Les transactions peuvent s'étendre facilement sur plusieurs schémas, facilitant les opérations qui nécessitent des garanties de consistance ACID à travers différents microservices.
- **Moins de complexité réseau** : Moins de points de défaillance potentiels et moins de complexité en matière de connectivité et de gestion des connexions.

**Inconvénients :**
- **Couplage élevé** : Les schémas dans la même base de données peuvent entraîner un couplage plus étroit entre les microservices, ce qui peut compliquer les migrations et les évolutions indépendantes.
- **Scalabilité limitée** : La scalabilité est limitée par la capacité de la base de données unique. Vous pourriez rencontrer des problèmes de performance lorsque la charge augmente.
- **Concurrence et verrouillage** : Les opérations concurrentes sur une seule base de données peuvent entraîner des problèmes de verrouillage et de contention, impactant les performances des microservices.

- **La procedure à suivre :** [Cliquez ici svp](https://github.com/bejaouibechir/CSharpLevel2/blob/J3/Approche%20base%20de%20donn%C3%A9es%20unique.md)

  </td>
  <td>
  Sharding de la Base de Données en Plusieurs Bases
  
**Avantages :**
- **Scalabilité** : Permet de répartir la charge et de mieux gérer des volumes de données plus importants en répartissant les données entre plusieurs bases de données.
- **Isolation des services** : Chaque microservice peut avoir sa propre base de données, réduisant le couplage et facilitant la gestion et l’évolution indépendante.
- **Performance améliorée** : Peut améliorer la performance en réduisant les conflits de verrouillage et en permettant des opérations plus efficaces à une échelle plus petite.

**Inconvénients :**
- **Complexité de gestion** : La gestion de plusieurs bases de données peut être complexe, nécessitant des mécanismes de synchronisation et de gestion des transactions distribuées.
- **Consistance transactionnelle** : Les transactions globales sur plusieurs bases de données peuvent être compliquées à mettre en œuvre, surtout si des transactions ACID sont nécessaires.
- **Complexité réseau** : Plus de points de défaillance potentiels et complexité accrue en matière de connectivité et de gestion des connexions entre les microservices et leurs bases de données.

- **La procédure à suivre**: [Cliquez ici svp](https://github.com/bejaouibechir/CSharpLevel2/blob/J3/Approche%20bases%20de%20donn%C3%A9es%20Slices.md)
  </td>
</table>



### Choix en Fonction des Besoins

- **Si vous recherchez la simplicité et une gestion centralisée** : L'utilisation d'une base de données unique avec des schémas distincts peut être plus appropriée, surtout si votre application ne nécessite pas une scalabilité massive et que les microservices ont des exigences de transaction relativement simples.

- **Si vous avez des besoins de scalabilité élevés et un couplage faible** : Le sharding avec plusieurs bases de données est généralement plus adapté, surtout pour des systèmes à grande échelle où chaque microservice doit évoluer indépendamment et gérer des volumes de données importants.

La meilleure approche dépendra donc de vos exigences spécifiques en matière de scalabilité, de gestion de données, et de complexité opérationnelle.

# Les défits au cas de choix de database slicing (Sharding)

Lorsqu'on choisit d'utiliser le sharding de base de données dans une architecture microservices, la gestion des relations (Primary Key, Foreign Key), des index et des permissions de sécurité devient plus complexe. Voici comment vous pouvez aborder ces aspects :

### 1. Relations (Primary Key, Foreign Key)

**Primary Keys :**
- Les clés primaires (Primary Keys) continuent de jouer leur rôle essentiel dans l'unicité des enregistrements dans chaque shard.
- Chaque shard doit garantir l'unicité des clés primaires pour ses propres données. Si vous utilisez un schéma de sharding basé sur une clé spécifique, vous devez vous assurer que la clé primaire reste unique dans le contexte de chaque shard.

**Foreign Keys :**
- Les clés étrangères (Foreign Keys) deviennent plus compliquées à gérer dans un environnement de sharding. Les relations entre données réparties sur différents shards ne sont pas gérées directement par la base de données.
- Vous devrez gérer l'intégrité référentielle au niveau de l'application plutôt qu'au niveau de la base de données. Cela signifie que les microservices doivent s'assurer que les données sont cohérentes et que les relations sont respectées via la logique de l'application.

**Approches possibles :**
- **Gestion au niveau de l'application :** Implémentez des mécanismes dans vos microservices pour vérifier et maintenir l'intégrité référentielle. Cela peut inclure des vérifications lors des opérations de lecture et d'écriture.
- **Coordination entre microservices :** Utilisez des patterns comme le **Saga Pattern** pour gérer des transactions distribuées et garantir la cohérence des données entre différents shards.

### 2. Index

**Index locaux :**
- Chaque shard doit gérer ses propres index pour optimiser les requêtes locales. Les index sont définis et maintenus indépendamment dans chaque shard.

**Index globaux :**
- La gestion des index globaux sur l'ensemble des shards est plus complexe. Vous devrez peut-être implémenter des solutions personnalisées pour les recherches qui nécessitent une vue d'ensemble des données réparties.
- Vous pouvez utiliser des outils ou des services de recherche distribuée (comme Elasticsearch) pour indexer et rechercher les données à travers plusieurs shards.

### 3. Sécurité et Permissions

**Sécurité des données :**
- Assurez-vous que chaque shard applique les contrôles de sécurité appropriés pour protéger les données. Cela inclut la gestion des accès et des permissions au niveau de chaque base de données shardée.

**Permissions d'accès :**
- Les permissions doivent être gérées indépendamment dans chaque shard. Vous devrez vous assurer que les contrôles d'accès sont cohérents et conformes aux politiques de sécurité de votre organisation dans tous les shards.

**Autorisations et authentification :**
- Implémentez des mécanismes d'authentification et d'autorisation au niveau des microservices pour contrôler l'accès aux données des différents shards. Vous pouvez également utiliser des solutions comme **OAuth** ou **JWT** pour gérer les permissions d'accès entre services.

**Approches possibles :**
- **Gestion centralisée :** Utilisez un service centralisé pour la gestion des utilisateurs et des permissions, en synchronisant les données et les permissions entre les microservices et les shards.
- **Audits et logs :** Mettez en place des mécanismes de journalisation et d'audit pour suivre les accès et les modifications des données à travers tous les shards.

### Résumé

- **Relations (Primary Key, Foreign Key) :** Gérer au niveau de l'application pour garantir l'intégrité référentielle à travers les shards.
- **Index :** Maintenir des index locaux dans chaque shard et utiliser des outils de recherche distribuée pour les requêtes globales.
- **Sécurité et Permissions :** Gérer les permissions indépendamment dans chaque shard et mettre en place des contrôles de sécurité centralisés au niveau des microservices.

La mise en œuvre du sharding nécessite donc une planification minutieuse pour s'assurer que toutes ces dimensions sont correctement prises en compte et que les microservices peuvent fonctionner de manière cohérente et sécurisée.

# Autres défit:
Voici d'autres défis associés au sharding de base de données :

- **Gestion de la cohérence des données**
- **Complexité de la migration des données**
- **Débogage et traçabilité des erreurs**
- **Synchronisation des données entre shards**
- **Gestion des requêtes globales**
- **Gestion des transactions distribuées**
- **Répartition inégale des données (data skew)**
- **Performance des opérations de join**
- **Complexité accrue des opérations de maintenance**
- **Déploiement et gestion des versions**
- **Backups et restaurations distribués**
- **Scalabilité des requêtes cross-shard**
- **Complexité de la configuration et de la gestion des clusters**
- **Gestion des défaillances et de la résilience**


  Explication plus détaillée:

  Voici les défis associés au sharding de base de données avec une brève explication pour chacun :

1. **Gestion de la cohérence des données** :
   - Assurer que les données restent cohérentes entre différents shards, surtout lorsque les mises à jour doivent être propagées à travers plusieurs bases.

2. **Complexité de la migration des données** :
   - La migration des données d'une base monolithique vers une architecture shardée peut être complexe, nécessitant une planification minutieuse et des outils appropriés.

3. **Débogage et traçabilité des erreurs** :
   - Les erreurs peuvent être plus difficiles à diagnostiquer en raison de la répartition des données et des opérations à travers plusieurs shards.

4. **Synchronisation des données entre shards** :
   - Assurer que les données modifiées dans un shard soient correctement synchronisées avec les autres shards lorsque cela est nécessaire.

5. **Gestion des requêtes globales** :
   - Les requêtes qui nécessitent des données provenant de plusieurs shards peuvent être difficiles à optimiser et à exécuter efficacement.

6. **Gestion des transactions distribuées** :
   - Les transactions qui touchent plusieurs shards doivent être gérées avec soin pour maintenir la cohérence des données et garantir l'atomicité.

7. **Répartition inégale des données (data skew)** :
   - La répartition des données entre shards peut devenir inégale, entraînant des problèmes de performance et de gestion lorsque certains shards deviennent des goulets d'étranglement.

8. **Performance des opérations de join** :
   - Les opérations de join entre des données réparties sur plusieurs shards peuvent être moins performantes et plus compliquées à exécuter.

9. **Complexité accrue des opérations de maintenance** :
   - Les opérations de maintenance, comme les sauvegardes et les mises à jour, doivent être effectuées sur plusieurs bases, augmentant la complexité.

10. **Déploiement et gestion des versions** :
    - La gestion des versions de l'application et des schémas de base de données à travers plusieurs shards peut compliquer les déploiements.

11. **Backups et restaurations distribués** :
    - La sauvegarde et la restauration doivent être effectuées pour chaque shard individuellement, ce qui peut compliquer la gestion des données.

12. **Scalabilité des requêtes cross-shard** :
    - Les requêtes qui nécessitent de combiner des résultats provenant de plusieurs shards peuvent rencontrer des limitations en termes de performance et de scalabilité.

13. **Complexité de la configuration et de la gestion des clusters** :
    - La configuration et la gestion des clusters de shards nécessitent une coordination étroite pour assurer une performance optimale et une disponibilité continue.

14. **Gestion des défaillances et de la résilience** :
    - Assurer que le système reste résilient face aux défaillances de certains shards et que les données restent accessibles et cohérentes malgré les problèmes.
