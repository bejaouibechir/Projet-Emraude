# TaskFactory

La classe **`TaskFactory`** en .NET est utilisée pour créer et planifier des tâches (instances de la classe `Task`). Elle permet de contrôler plus finement la manière dont les tâches sont créées et exécutées, avec des options avancées comme la gestion de la planification et les options de tâche par défaut.

Passons à la présentation complète de **`TaskFactory`** selon le même schéma utilisé pour la classe `Task` :

``` mermaid
graph TD
    A[TaskFactory] --> B1[Création de tâches]
    B1 --> C1[StartNew-Action]
    B1 --> C2[StartNew-Func<T>]
    B1 --> C3[StartNew avec TaskCreationOptions]
    C3 --> D1[TaskCreationOptions.LongRunning]
    C3 --> D2[TaskCreationOptions.DenyChildAttach]
    C3 --> D3[TaskCreationOptions.PreferFairness]

```
``` mermaid
graph TD
    A[TaskFactory] --> B2[Annulation]
    B2 --> C1[Annulation via CancellationToken]
    C1 --> D1[Demande d'annulation]
    D1 --> E1[La tâche est annulée]
    C1 --> D2[Pas d'annulation]
    D2 --> E2[La tâche continue]

```
``` mermaid
graph TD
    A[TaskFactory] --> B3[Continuation]
    B3 --> C1[Continuation avec TaskContinuationOptions]
    C1 --> D1[OnlyOnRanToCompletion]
    D1 --> E1[Tâche réussie, exécution de la continuation]
    C1 --> D2[OnlyOnFaulted]
    D2 --> E2[La tâche a échoué, exécution de la continuation]

```
``` mermaid
graph TD
    A[TaskFactory] --> B4[Planification avec TaskScheduler]
    B4 --> C1[TaskScheduler par défaut]
    B4 --> C2[TaskScheduler personnalisé]
    C2 --> D1[Exécution séquentielle]
    C2 --> D2[Exécution concurrente limitée]

```
---

### 1. Comparaison entre `Task` et `TaskFactory`

- **`Task`** :
  - `Task` est une classe de haut niveau qui représente une opération asynchrone ou une unité de travail.
  - 
    Elle est simple à utiliser avec `Task.Run`, `async/await`, et fournit un ensemble de fonctionnalités comme l'annulation et les continuations.

  - **Approprié pour** : La gestion directe de tâches individuelles, particulièrement lorsqu'il s'agit de scénarios simples.

- **`TaskFactory`** :
  - `TaskFactory` est une classe qui fournit des méthodes pour créer et planifier des tâches avec un contrôle plus détaillé.

    Elle permet de définir des options par défaut comme `les options de planification, les options d'annulation, etc.` pour chaque tâche créée via la fabrique.
  
  - **Approprié pour** : Les scénarios où il est nécessaire de configurer de manière uniforme un grand nombre de tâches, ou lorsqu'il est important d'avoir un contrôle avancé
  
    par exemple, définir des options spécifiques de tâches ou de planification.

### Schéma de comparaison

Voici une comparaison visuelle sous forme de tableau :

| Aspect               | `Task`                        | `TaskFactory`                                      |
|----------------------|-------------------------------|---------------------------------------------------|
| Création              | Simple (`Task.Run`)           | Via `TaskFactory.StartNew()` avec options étendues |
| Planification         | Automatique                   | Personnalisable via `TaskScheduler`                |
| Utilisation           | Scénarios simples             | Scénarios complexes avec contrôle étendu           |

---

### 2. Nouveautés dans `TaskFactory` : Annulation et Continuation

#### Annulation avec `TaskFactory`
De la même manière que `Task`, la classe `TaskFactory` peut utiliser des jetons d'annulation (`CancellationToken`), 

mais elle peut aussi configurer un jeton d'annulation par défaut pour toutes les tâches qu'elle crée.

**Exemple d'annulation avec `TaskFactory`** :
```csharp
CancellationTokenSource cts = new CancellationTokenSource();
CancellationToken token = cts.Token;

TaskFactory factory = new TaskFactory(token);

Task task = factory.StartNew(() =>
{
    for (int i = 0; i < 10; i++)
    {
        if (token.IsCancellationRequested)
        {
            Console.WriteLine("Tâche annulée via TaskFactory.");
            return;
        }
        Console.WriteLine($"Itération {i}");
        Thread.Sleep(500);  // Simuler du travail
    }
});

// Annuler la tâche après 2 secondes
Task.Delay(2000).ContinueWith(t => cts.Cancel());
task.Wait();
```

#### Continuation avec `TaskFactory`
La création de continuations fonctionne de manière similaire à `Task`, mais avec plus de contrôle via `TaskFactory`.

**Exemple de continuation avec `TaskFactory`** :
```csharp
TaskFactory factory = new TaskFactory();
Task<int> firstTask = factory.StartNew(() =>
{
    Console.WriteLine("Première tâche dans TaskFactory.");
    return 42;
});

Task continuationTask = firstTask.ContinueWith(t =>
{
    Console.WriteLine($"Continuation avec résultat : {t.Result}");
});

continuationTask.Wait();
```

---

### 3. Diverses techniques d'instanciation de `TaskFactory`

**`TaskFactory`** permet de créer des tâches de différentes manières, tout en offrant des options supplémentaires de planification et de contrôle.

1. **Utilisation de `TaskFactory.StartNew()`** :
   - Méthode pour créer et démarrer immédiatement une tâche.
   ```csharp
   TaskFactory factory = new TaskFactory();
   factory.StartNew(() => Console.WriteLine("Tâche créée avec TaskFactory.StartNew"));
   ```

2. **Définir un planificateur personnalisé avec `TaskScheduler`** :
   - Vous pouvez passer un `TaskScheduler` personnalisé pour contrôler la manière dont les tâches sont planifiées.
   ```csharp
   TaskScheduler scheduler = TaskScheduler.Default;  // Peut être personnalisé
   TaskFactory factory = new TaskFactory(scheduler);
   factory.StartNew(() => Console.WriteLine("Tâche avec planificateur personnalisé"));
   ```

3. **Création d'une tâche avec options de continuation** :
   - Vous pouvez utiliser `TaskFactory` pour configurer des options avancées de continuation.
   ```csharp
   TaskFactory factory = new TaskFactory();
   Task task = factory.StartNew(() => Console.WriteLine("Tâche avec TaskFactory"));
   Task continuationTask = factory.ContinueWhenAny(new[] { task }, t => Console.WriteLine("Continuation après la première tâche"));
   continuationTask.Wait();
   ```

---

### 4. Membres importants de la classe `TaskFactory` (énumération)

1. **`StartNew(Action)`** 
   - Crée et démarre immédiatement une nouvelle tâche.
   
2. **`ContinueWhenAny(Task[], Action<Task>)`**
   - Crée une tâche de continuation qui démarre lorsqu'une des tâches spécifiées est terminée.

3. **`ContinueWhenAll(Task[], Action<Task[]>)`**
   - Crée une tâche de continuation qui démarre lorsque toutes les tâches spécifiées sont terminées.

4. **`CancellationToken`**
   - Renvoie le jeton d'annulation associé à cette fabrique.

5. **`TaskScheduler`**
   - Renvoie le planificateur de tâches associé à cette fabrique, qui peut être personnalisé pour contrôler la planification des tâches.

6. **`CreationOptions`**
   - Renvoie les options de création par défaut pour les tâches créées par cette fabrique.

7. **`CompletionOptions`**
   - Renvoie les options de continuation par défaut pour les tâches créées par cette fabrique.

---

### 5. Membres importants de `TaskFactory` (exemples d'implémentation)

#### 1. **`StartNew(Action)`**
```csharp
TaskFactory factory = new TaskFactory();
factory.StartNew(() => Console.WriteLine("Tâche créée avec StartNew."));
```

#### 2. **`ContinueWhenAny(Task[], Action<Task>)`**
```csharp
TaskFactory factory = new TaskFactory();
Task task1 = factory.StartNew(() => Thread.Sleep(1000));
Task task2 = factory.StartNew(() => Thread.Sleep(1500));

factory.ContinueWhenAny(new[] { task1, task2 }, t => Console.WriteLine("Première tâche terminée.")).Wait();
```

#### 3. **`ContinueWhenAll(Task[], Action<Task[]>)`**
```csharp
TaskFactory factory = new TaskFactory();
Task task1 = factory.StartNew(() => Thread.Sleep(1000));
Task task2 = factory.StartNew(() => Thread.Sleep(1500));

factory.ContinueWhenAll(new[] { task1, task2 }, tasks => Console.WriteLine("Toutes les tâches sont terminées.")).Wait();
```

#### 4. **`CancellationToken`**
```csharp
CancellationTokenSource cts = new CancellationTokenSource();
TaskFactory factory = new TaskFactory(cts.Token);

Task task = factory.StartNew(() =>
{
    if (cts.Token.IsCancellationRequested)
    {
        Console.WriteLine("Tâche annulée.");
        return;
    }
    Console.WriteLine("Tâche en cours.");
});

// Annuler la tâche
cts.Cancel();
task.Wait();
```

#### 5. **`TaskScheduler`**
```csharp
TaskScheduler scheduler = TaskScheduler.Default;
TaskFactory factory = new TaskFactory(scheduler);

factory.StartNew(() => Console.WriteLine("Tâche planifiée avec TaskScheduler.Default")).Wait();
```

---

### 6. Exemple de synthèse qui groupe l'ensemble des membres importants

Cet exemple combine plusieurs fonctionnalités de `TaskFactory`, notamment la création de tâches, les continuations, et l'utilisation d'un jeton d'annulation.

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        CancellationTokenSource cts = new CancellationTokenSource();
        TaskScheduler scheduler = TaskScheduler.Default;

        // Création d'une TaskFactory avec un token d'annulation et un planificateur personnalisé
        TaskFactory factory = new TaskFactory(cts.Token, TaskCreationOptions.None, TaskContinuationOptions.None, scheduler);

        // Création d'une tâche
        Task task1 = factory.StartNew(() =>
        {
            Console.WriteLine("Tâche 1 en cours.");
            Thread.Sleep(1000);
        });

        // Création d'une deuxième tâche
        Task task2 = factory.StartNew(() =>
        {
            Console.WriteLine("Tâche 2 en cours.");
            Thread.Sleep(1500);
        });

        // Continuation après la première tâche terminée
        Task continuationTask = factory.ContinueWhenAny(new[] { task1, task2 }, t =>


        {
            Console.WriteLine("Une des tâches est terminée.");
        });

        // Annuler après 2 secondes (affectera les nouvelles tâches)
        Task.Delay(2000).ContinueWith(t => cts.Cancel());

        continuationTask.Wait();
        Console.WriteLine("Fin du programme.");
    }
}
```

### Explication :
- Le programme crée deux tâches avec une fabrique (`TaskFactory`) associée à un jeton d'annulation.
- Une tâche de continuation est créée pour s'exécuter lorsque l'une des deux tâches se termine.
- Le programme utilise un planificateur par défaut (`TaskScheduler.Default`).
- Après 2 secondes, le jeton d'annulation est déclenché, ce qui pourrait affecter toute tâche future créée avec cette fabrique.

---

# Des notions avancées

Voici quelques notions avancées sur **`TaskFactory`** en .NET qui n'ont peut-être pas encore été abordées dans le cadre précédent. 

Ces notions permettent de mieux comprendre les possibilités offertes par `TaskFactory` pour des scénarios plus complexes et spécifiques.

### 1. **Surcharge de `TaskFactory` pour différentes signatures de méthodes**

L'une des particularités de `TaskFactory` est qu'il offre **de nombreuses surcharges** pour créer des tâches, ce qui le rend plus flexible que `Task.Run`. Par exemple, vous pouvez créer des tâches qui retournent un résultat (`Task<TResult>`), qui acceptent des arguments, ou qui utilisent différents contextes de planification et d'annulation.

- **Création de tâches avec résultat (`Task<TResult>`)** :
  - `TaskFactory` permet de créer des tâches qui retournent un résultat, ce qui est utile pour les opérations asynchrones où vous devez récupérer une valeur.
  
  **Exemple** :
  ```csharp
  TaskFactory<int> factory = new TaskFactory<int>();
  Task<int> taskWithResult = factory.StartNew(() =>
  {
      Console.WriteLine("Calcul en cours...");
      return 42;
  });

  Console.WriteLine($"Résultat de la tâche : {taskWithResult.Result}");
  ```

- **Utilisation de paramètres d'état** :
  - Vous pouvez aussi passer un paramètre d'état aux tâches. Cela est utile lorsque vous voulez partager des données entre la création et l'exécution de la tâche.
  
  **Exemple** :
  ```csharp
  TaskFactory factory = new TaskFactory();
  Task taskWithState = factory.StartNew((state) =>
  {
      Console.WriteLine($"Exécution avec état : {state}");
  }, "Paramètre d'état");

  taskWithState.Wait();
  ```

### 2. **Support des options avancées de création de tâches (`TaskCreationOptions`)**

`TaskFactory` permet de définir des options de création de tâches via **`TaskCreationOptions`**. Ces options permettent de modifier le comportement d'une tâche lors de sa création. Voici quelques-unes des options les plus courantes :

- **`TaskCreationOptions.LongRunning`** : Indique que la tâche est une opération longue et qu'elle ne doit pas utiliser un thread du pool de threads. Au lieu de cela, un thread dédié sera utilisé pour cette tâche.

  **Exemple** :
  ```csharp
  TaskFactory factory = new TaskFactory();
  Task longRunningTask = factory.StartNew(() =>
  {
      Console.WriteLine("Tâche longue en cours...");
      Thread.Sleep(5000);  // Simuler une opération longue
      Console.WriteLine("Tâche longue terminée.");
  }, TaskCreationOptions.LongRunning);

  longRunningTask.Wait();
  ```

- **`TaskCreationOptions.DenyChildAttach`** : Indique que les sous-tâches créées par cette tâche ne peuvent pas être attachées en tant qu'enfants à la tâche principale. Cela affecte les tâches parente/enfant, où les sous-tâches héritent du contexte d'exécution de la tâche parente.

- **`TaskCreationOptions.PreferFairness`** : Indique que la tâche doit être planifiée de manière équitable, en respectant l'ordre dans lequel elle a été créée par rapport aux autres tâches.

  **Exemple** :
  ```csharp
  TaskFactory factory = new TaskFactory();
  Task fairTask = factory.StartNew(() =>
  {
      Console.WriteLine("Tâche avec préférence de planification équitable.");
  }, TaskCreationOptions.PreferFairness);

  fairTask.Wait();
  ```

### 3. **Combinaison avec `TaskScheduler` pour personnaliser la planification**

La planification des tâches en .NET est habituellement effectuée via le **pool de threads** par défaut, mais `TaskFactory` permet de spécifier un **`TaskScheduler`** personnalisé pour contrôler comment les tâches sont planifiées et exécutées.

- **`TaskScheduler` personnalisé** : Vous pouvez créer un planificateur de tâches personnalisé qui gère les tâches de manière spécifique, par exemple en créant un planificateur séquentiel ou limité à un certain nombre de threads simultanés.
  
  **Exemple basique d'utilisation du `TaskScheduler.Default`** :
  ```csharp
  TaskScheduler scheduler = TaskScheduler.Default;  // Le planificateur par défaut
  TaskFactory factory = new TaskFactory(scheduler);

  factory.StartNew(() => Console.WriteLine("Tâche planifiée avec le TaskScheduler.Default")).Wait();
  ```

### 4. **Options de continuation avancées avec `TaskContinuationOptions`**

`TaskFactory` permet aussi de spécifier des options avancées pour les **continuations** de tâches via `TaskContinuationOptions`. Voici quelques-unes des options importantes :

- **`TaskContinuationOptions.OnlyOnRanToCompletion`** : La continuation ne s'exécute que si la tâche principale a réussi (c'est-à-dire qu'elle s'est terminée sans erreur).
  
  **Exemple** :
  ```csharp
  TaskFactory factory = new TaskFactory();
  Task task = factory.StartNew(() => Console.WriteLine("Tâche principale terminée avec succès."));
  
  Task continuation = task.ContinueWith(t =>
  {
      Console.WriteLine("Continuation exécutée uniquement si la tâche principale a réussi.");
  }, TaskContinuationOptions.OnlyOnRanToCompletion);

  continuation.Wait();
  ```

- **`TaskContinuationOptions.OnlyOnFaulted`** : La continuation ne s'exécute que si la tâche principale a échoué avec une exception.
  
  **Exemple** :
  ```csharp
  TaskFactory factory = new TaskFactory();
  Task task = factory.StartNew(() =>
  {
      throw new Exception("Erreur dans la tâche principale.");
  });

  Task continuation = task.ContinueWith(t =>
  {
      Console.WriteLine("Continuation exécutée uniquement si la tâche principale a échoué.");
  }, TaskContinuationOptions.OnlyOnFaulted);

  continuation.Wait();
  ```

### 5. **Contrôle avancé du `TaskScheduler` pour exécuter des tâches séquentiellement**

Un scénario spécifique est la nécessité de forcer une exécution séquentielle de tâches plutôt qu'en parallèle. Cela peut être accompli en utilisant un `TaskScheduler` personnalisé avec `TaskFactory`.

Voici une idée simple pour illustrer le concept (même si l'implémentation d'un `TaskScheduler` personnalisé peut être complexe) :

- **Planification séquentielle** : Les tâches peuvent être exécutées l'une après l'autre plutôt que simultanément en modifiant la manière dont elles sont planifiées.

```csharp
public class SequentialTaskScheduler : TaskScheduler
{
    private readonly Queue<Task> _tasks = new Queue<Task>();
    private readonly object _lock = new object();

    protected override IEnumerable<Task> GetScheduledTasks()
    {
        lock (_lock)
        {
            return _tasks.ToArray();
        }
    }

    protected override void QueueTask(Task task)
    {
        lock (_lock)
        {
            _tasks.Enqueue(task);
        }
        TryExecuteNextTask();
    }

    private void TryExecuteNextTask()
    {
        lock (_lock)
        {
            if (_tasks.Count > 0)
            {
                Task nextTask = _tasks.Dequeue();
                TryExecuteTask(nextTask);
            }
        }
    }

    protected override bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued)
    {
        return TryExecuteTask(task);
    }
}

// Utilisation du TaskScheduler personnalisé
SequentialTaskScheduler scheduler = new SequentialTaskScheduler();
TaskFactory factory = new TaskFactory(scheduler);

Task task1 = factory.StartNew(() => Console.WriteLine("Tâche 1 exécutée."));
Task task2 = factory.StartNew(() => Console.WriteLine("Tâche 2 exécutée."));

Task.WaitAll(task1, task2);
```

### 6. **Planification optimisée pour des tâches longues et coûteuses**

Pour des scénarios où certaines tâches sont particulièrement longues ou gourmandes en ressources, `TaskFactory` peut être configurée avec l'option **`TaskCreationOptions.LongRunning`**. Cela signale au runtime que ces tâches ne doivent pas être exécutées sur les threads du pool de threads par défaut, mais sur des threads dédiés.

```csharp
TaskFactory factory = new TaskFactory();
Task longRunningTask = factory.StartNew(() =>
{
    // Simuler une tâche longue
    Console.WriteLine("Exécution d'une tâche longue.");
    Thread.Sleep(5000);
}, TaskCreationOptions.LongRunning);

longRunningTask.Wait();
Console.WriteLine("Tâche longue terminée.");
```

### Conclusion des points avancés sur `TaskFactory` :

- **Flexibilité et contrôle** : `TaskFactory` permet de configurer des options avancées pour la création et la gestion des tâches, ce qui offre plus de contrôle sur les comportements par défaut. Cela comprend l'annulation, les options de continuation, et l'optimisation des tâches longues.
- **Personnalisation via `TaskScheduler`** : La personnalisation du planificateur de tâches permet une gestion fine de la manière dont les tâches sont planifiées, exécutées, et parallélisées.
- **Gestion des tâches complexes** : Les fonctionnalités de `TaskFactory` permettent de gérer plus efficacement les scénarios complexes avec plusieurs tâches, des priorités, et des besoins de synchronisation spécifiques.

Ces fonctionnalités permettent à **`TaskFactory`** de mieux répondre aux besoins des développeurs dans des scénarios où un contrôle plus détaillé est requis pour l'exécution et la planification des tâches en parallèle ou de manière séquentielle.



