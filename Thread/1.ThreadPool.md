# Présentation de ThreadPool

La classe `ThreadPool` offre plusieurs avantages par rapport à la classe `Thread` en .NET. Voici les principaux points à considérer :

## Thread  vs ThreadPool

### 1. **Gestion des ressources**
   - **ThreadPool** : Gère automatiquement un ensemble de threads réutilisables, ce qui permet de minimiser le coût de création et de destruction de threads. Les threads sont réutilisés pour exécuter différentes tâches au lieu d'en créer de nouveaux à chaque fois.
   - **Thread** : Chaque fois que vous créez une nouvelle instance de `Thread`, un thread distinct est alloué, avec des frais associés à la création et à la gestion du cycle de vie de ce thread.

### 2. **Optimisation des performances**
   - **ThreadPool** : Optimise l'utilisation des threads en ajustant dynamiquement le nombre de threads en fonction de la charge du système. Il utilise un modèle de file d'attente pour exécuter les tâches, ce qui est plus efficace pour des petites tâches qui doivent être exécutées rapidement.
   - **Thread** : Chaque thread est indépendant, et le développeur doit gérer manuellement la création, le démarrage et la gestion des threads. Cela peut entraîner une surcharge importante, surtout lorsque de nombreux threads sont nécessaires.

### 3. **Facilité d'utilisation**
   - **ThreadPool** : Permet d'exécuter facilement des tâches en arrière-plan en appelant simplement `ThreadPool.QueueUserWorkItem` ou via des abstractions comme les `Task`. Vous n'avez pas besoin de gérer directement les threads.
   - **Thread** : Nécessite de gérer manuellement le cycle de vie des threads, ce qui peut rendre le code plus complexe.

### 4. **Limitation et contrôle**
   - **ThreadPool** : Vous avez moins de contrôle direct sur chaque thread. Par exemple, vous ne pouvez pas définir la priorité des threads du pool ou arrêter directement un thread spécifique. Toutefois, il est adapté pour la plupart des scénarios de multitâche.
   - **Thread** : Vous avez un contrôle total sur chaque thread (priorité, gestion des exceptions, etc.), ce qui peut être utile dans certains scénarios spécifiques nécessitant une gestion fine des threads.

### 5. **Adaptation pour les tâches courtes vs longues**
   - **ThreadPool** : Idéal pour des tâches courtes ou répétitives. Le pool de threads peut gérer efficacement une grande quantité de petites tâches.
   - **Thread** : Peut être plus adapté si vous devez exécuter une tâche longue durée ou des opérations où vous avez besoin de plus de contrôle, comme des threads de longue durée ayant des exigences spécifiques.

### Exemple d'utilisation simplifiée :

**ThreadPool** (gestion automatique) :
```csharp
ThreadPool.QueueUserWorkItem(_ =>
{
    Console.WriteLine("Tâche exécutée dans le ThreadPool.");
});
```

**Thread** (gestion manuelle) :
```csharp
Thread thread = new Thread(() =>
{
    Console.WriteLine("Tâche exécutée dans un Thread dédié.");
});
thread.Start();
```

## Les membres de la classe ThreadPool

Voici une énumération des membres importants de la classe `ThreadPool` en .NET, avec une brève description :

**`QueueUserWorkItem(WaitCallback)`**: Enfile une tâche pour exécution dans le pool de threads.

**`QueueUserWorkItem(WaitCallback, Object)`**:Enfile une tâche avec un paramètre d'état à exécuter dans le pool de threads.

**`RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, TimeSpan, Boolean)`**: Enregistre un objet d'attente pour surveiller son état ou déclencher une action après un délai.

**`SetMinThreads(int workerThreads, int completionPortThreads)`**: Définit le nombre minimum de threads de travail et de threads d'E/S asynchrones dans le pool.

**`SetMaxThreads(int workerThreads, int completionPortThreads)`**: Définit le nombre maximum de threads de travail et de threads d'E/S asynchrones dans le pool.

**`GetMinThreads(out int workerThreads, out int completionPortThreads)`**: Obtient le nombre minimum de threads dans le pool.

**`GetMaxThreads(out int workerThreads, out int completionPortThreads)`**: Obtient le nombre maximum de threads dans le pool.

**`GetAvailableThreads(out int workerThreads, out int completionPortThreads)`**: Obtient le nombre de threads disponibles pour exécuter des tâches dans le pool.

**`UnsafeQueueUserWorkItem(WaitCallback, Object)`**: Enfile une tâche sans vérifier les autorisations de sécurité (utilisation avancée).

**`UnsafeRegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, TimeSpan, Boolean)`**: Enregistre un objet d'attente sans vérification de sécurité.

Voici des exemples de code pour chaque membre important de la classe `ThreadPool` en .NET :

### 1. **`QueueUserWorkItem(WaitCallback)`**
Enfile une tâche simple dans le pool de threads.
```csharp
ThreadPool.QueueUserWorkItem(state => 
{
    Console.WriteLine("Tâche exécutée dans le ThreadPool.");
});
```

### 2. **`QueueUserWorkItem(WaitCallback, Object)`**
Enfile une tâche avec un paramètre d'état.
```csharp
ThreadPool.QueueUserWorkItem(state => 
{
    Console.WriteLine($"État : {state}");
}, "Mon état personnalisé");
```

### 3. **`RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, TimeSpan, Boolean)`**
Enregistre un `WaitHandle` pour déclencher une tâche lorsqu'il est signalé ou après un délai.
```csharp
AutoResetEvent autoEvent = new AutoResetEvent(false);

ThreadPool.RegisterWaitForSingleObject(
    autoEvent, 
    (state, timedOut) => 
    {
        if (!timedOut)
            Console.WriteLine("L'événement a été déclenché !");
        else
            Console.WriteLine("Délai expiré !");
    }, 
    null, 
    TimeSpan.FromSeconds(5), 
    true
);

// Simuler un déclenchement après 2 secondes
Task.Delay(2000).ContinueWith(t => autoEvent.Set());
```

### 4. **`SetMinThreads(int workerThreads, int completionPortThreads)`**
Définit le nombre minimum de threads dans le pool.
```csharp
ThreadPool.SetMinThreads(4, 4);
Console.WriteLine("Nombre minimum de threads défini.");
```

### 5. **`SetMaxThreads(int workerThreads, int completionPortThreads)`**
Définit le nombre maximum de threads dans le pool.
```csharp
ThreadPool.SetMaxThreads(16, 16);
Console.WriteLine("Nombre maximum de threads défini.");
```

### 6. **`GetMinThreads(out int workerThreads, out int completionPortThreads)`**
Obtient le nombre minimum de threads configurés dans le pool.
```csharp
ThreadPool.GetMinThreads(out int workerThreads, out int completionPortThreads);
Console.WriteLine($"Minimum de threads de travail : {workerThreads}, Minimum de threads d'E/S : {completionPortThreads}");
```

### 7. **`GetMaxThreads(out int workerThreads, out int completionPortThreads)`**
Obtient le nombre maximum de threads configurés dans le pool.
```csharp
ThreadPool.GetMaxThreads(out int workerThreads, out int completionPortThreads);
Console.WriteLine($"Maximum de threads de travail : {workerThreads}, Maximum de threads d'E/S : {completionPortThreads}");
```

### 8. **`GetAvailableThreads(out int workerThreads, out int completionPortThreads)`**
Obtient le nombre de threads disponibles dans le pool.
```csharp
ThreadPool.GetAvailableThreads(out int workerThreads, out int completionPortThreads);
Console.WriteLine($"Threads disponibles : {workerThreads}, Threads d'E/S disponibles : {completionPortThreads}");
```

### 9. **`UnsafeQueueUserWorkItem(WaitCallback, Object)`**
Enfile une tâche dans le pool de threads sans vérification de sécurité.
```csharp
ThreadPool.UnsafeQueueUserWorkItem(state => 
{
    Console.WriteLine($"Tâche non sécurisée exécutée avec l'état : {state}");
}, "État non sécurisé");
```

### 10. **`UnsafeRegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, TimeSpan, Boolean)`**
Enregistre un `WaitHandle` sans vérification de sécurité.
```csharp
AutoResetEvent autoEventUnsafe = new AutoResetEvent(false);

ThreadPool.UnsafeRegisterWaitForSingleObject(
    autoEventUnsafe, 
    (state, timedOut) => 
    {
        if (!timedOut)
            Console.WriteLine("L'événement non sécurisé a été déclenché !");
        else
            Console.WriteLine("Délai non sécurisé expiré !");
    }, 
    null, 
    TimeSpan.FromSeconds(3), 
    true
);

// Simuler un déclenchement après 1 seconde
Task.Delay(1000).ContinueWith(t => autoEventUnsafe.Set());
```

## Un exemple complet

Voici un exemple qui combine plusieurs membres de la classe `ThreadPool`. L'idée est de démontrer comment gérer plusieurs tâches asynchrones, surveiller un objet `WaitHandle` avec un délai d'attente, et manipuler les paramètres de threads dans le pool (minimum et maximum), tout en utilisant à la fois les méthodes sécurisées et non sécurisées.

### Exemple complet :
```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        // 1. Définir le nombre minimum et maximum de threads
        ThreadPool.SetMinThreads(2, 2);  // 2 threads de travail, 2 threads de port de complétion
        ThreadPool.SetMaxThreads(8, 8);  // 8 threads de travail, 8 threads de port de complétion

        // 2. Afficher les informations sur les threads disponibles
        ThreadPool.GetMinThreads(out int minWorker, out int minCompletion);
        ThreadPool.GetMaxThreads(out int maxWorker, out int maxCompletion);
        ThreadPool.GetAvailableThreads(out int availableWorker, out int availableCompletion);
        Console.WriteLine($"Min Threads: {minWorker}, {minCompletion}");
        Console.WriteLine($"Max Threads: {maxWorker}, {maxCompletion}");
        Console.WriteLine($"Available Threads: {availableWorker}, {availableCompletion}");

        // 3. Enfiler une tâche simple dans le ThreadPool
        ThreadPool.QueueUserWorkItem(state =>
        {
            Console.WriteLine("Tâche simple exécutée dans le pool de threads.");
        });

        // 4. Enfiler une tâche avec un paramètre d'état
        ThreadPool.QueueUserWorkItem(state =>
        {
            Console.WriteLine($"Tâche avec état : {state}");
        }, "Mon paramètre d'état");

        // 5. Utiliser RegisterWaitForSingleObject pour attendre un AutoResetEvent avec un délai
        AutoResetEvent autoEvent = new AutoResetEvent(false);
        ThreadPool.RegisterWaitForSingleObject(autoEvent, (state, timedOut) =>
        {
            if (timedOut)
                Console.WriteLine("Délai expiré avant le déclenchement de l'événement.");
            else
                Console.WriteLine("L'événement a été déclenché !");
        }, null, TimeSpan.FromSeconds(3), true);

        // Simuler le déclenchement après 2 secondes
        Task.Delay(2000).ContinueWith(t => autoEvent.Set());

        // 6. Utiliser UnsafeQueueUserWorkItem pour une tâche non sécurisée
        ThreadPool.UnsafeQueueUserWorkItem(state =>
        {
            Console.WriteLine($"Tâche non sécurisée exécutée avec état : {state}");
        }, "État non sécurisé");

        // 7. Utiliser UnsafeRegisterWaitForSingleObject pour un objet d'attente sans vérification de sécurité
        AutoResetEvent autoEventUnsafe = new AutoResetEvent(false);
        ThreadPool.UnsafeRegisterWaitForSingleObject(autoEventUnsafe, (state, timedOut) =>
        {
            if (timedOut)
                Console.WriteLine("Délai non sécurisé expiré.");
            else
                Console.WriteLine("Événement non sécurisé déclenché !");
        }, null, TimeSpan.FromSeconds(4), true);

        // Simuler un déclenchement après 3 secondes pour l'événement non sécurisé
        Task.Delay(3000).ContinueWith(t => autoEventUnsafe.Set());

        // 8. Boucle pour attendre les tâches asynchrones
        Console.WriteLine("En attente des événements...");
        Task.Delay(5000).Wait();  // Attendre 5 secondes pour s'assurer que toutes les tâches sont terminées

        Console.WriteLine("Fin du programme.");
    }
}
```

1. **Configuration des threads** : 
   - On utilise `SetMinThreads` et `SetMaxThreads` pour définir les limites du pool de threads.
   - On utilise `GetMinThreads`, `GetMaxThreads` et `GetAvailableThreads` pour obtenir des informations sur la configuration du pool.

2. **Tâches avec et sans état** : 
   - `QueueUserWorkItem` est utilisé pour enfile une tâche simple et une tâche avec un paramètre d'état.
   
3. **Attente d'événements** :
   - `RegisterWaitForSingleObject` et `UnsafeRegisterWaitForSingleObject` sont utilisés pour surveiller deux objets `AutoResetEvent` avec des délais différents.
   - Un événement sécurisé est déclenché après 2 secondes, tandis qu'un autre événement non sécurisé est déclenché après 3 secondes.

4. **Tâches non sécurisées** : 
   - `UnsafeQueueUserWorkItem` et `UnsafeRegisterWaitForSingleObject` démontrent l'utilisation de ces méthodes sans vérification de sécurité.

5. **Attente finale** : 
   - Un délai de 5 secondes est mis en place à la fin pour s'assurer que toutes les tâches et événements ont été exécutés avant que le programme ne se termine.

### Résultat attendu :
```
Min Threads: 2, 2
Max Threads: 8, 8
Available Threads: 8, 8
Tâche simple exécutée dans le pool de threads.
Tâche avec état : Mon paramètre d'état
L'événement a été déclenché !
Tâche non sécurisée exécutée avec état : État non sécurisé
Événement non sécurisé déclenché !
Fin du programme.
```

Cet exemple démontre comment combiner plusieurs membres de la classe `ThreadPool` pour gérer des tâches parallèles et des événements en .NET. ✔️



### Conclusion :
Dans la majorité des cas, **`ThreadPool` est plus efficace** et plus facile à utiliser que `Thread`, surtout pour des tâches courtes et parallélisables. 
