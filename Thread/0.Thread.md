# Présentation de la classe Thread

En .NET, la classe `Thread` appartient à l'espace de noms `System.Threading` et permet de créer et gérer des threads `ou processus légers`. 

Chaque thread représente `une unité d'exécution distincte`, permettant de réaliser plusieurs tâches simultanément `concurrence` au sein d'une même application.

## Exemple simple d'utilisation de la classe `Thread`

Voici un exemple de création et de gestion d'un thread en C# :

```csharp
using System;
using System.Threading;

class Program
{
    // Méthode qui sera exécutée dans un nouveau thread
    static void TaskToRun()
    {
        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine($"Thread secondaire: {i}");
            Thread.Sleep(1000); // Pause de 1 seconde
        }
    }

    static void Main()
    {
        // Création d'un nouveau thread et assignation de la méthode à exécuter
        Thread newThread = new Thread(new ThreadStart(TaskToRun));

        // Démarrage du thread
        newThread.Start();

        // Code dans le thread principal
        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine($"Thread principal: {i}");
            Thread.Sleep(500); // Pause de 0,5 seconde
        }

        // Attendre la fin de l'exécution du thread secondaire
        newThread.Join();

        Console.WriteLine("Fin du programme.");
    }
}
```

## Exemple d'exécution de Thread avec passage de paramètre(s)

La classe `Thread` en .NET permet d'exécuter du code dans un thread séparé. L'utilisation de **`ParameterizedThreadStart`** permet de passer un paramètre à la méthode exécutée par le thread, ce qui est utile lorsque vous devez fournir des données spécifiques à un thread sans utiliser de variables globales.

### Scénario : Téléchargement parallèle de fichiers avec des URLs fournies en paramètre

Imaginons une application qui doit télécharger plusieurs fichiers à partir de différentes URLs. Pour chaque téléchargement, nous lançons un thread et passons l'URL correspondante en tant que paramètre.

```csharp
using System;
using System.Threading;

class FileDownloader
{
    // Méthode exécutée dans chaque thread pour télécharger un fichier
    public static void DownloadFile(object url)
    {
        string fileUrl = (string)url; // Caster le paramètre en string
        Console.WriteLine($"Démarrage du téléchargement à partir de {fileUrl} dans le thread {Thread.CurrentThread.ManagedThreadId}");

        // Simuler le téléchargement en mettant le thread en pause
        Thread.Sleep(3000); // Simuler un téléchargement qui prend 3 secondes

        Console.WriteLine($"Téléchargement terminé pour {fileUrl}");
    }

    static void Main()
    {
        // Liste d'URLs de fichiers à télécharger
        string[] fileUrls = {
            "https://example.com/fichier1.zip",
            "https://example.com/fichier2.zip",
            "https://example.com/fichier3.zip"
        };

        // Démarrer un thread pour chaque téléchargement
        foreach (string url in fileUrls)
        {
            // Créer un nouveau thread avec ParameterizedThreadStart pour passer l'URL en paramètre
            Thread downloadThread = new Thread(new ParameterizedThreadStart(DownloadFile));

            // Démarrer le thread en passant l'URL
            downloadThread.Start(url);
        }

        // Attendre que tous les téléchargements soient terminés
        Console.WriteLine("Tous les téléchargements ont été démarrés. Appuyez sur Entrée pour quitter.");
        Console.ReadLine(); // Attendre l'entrée de l'utilisateur pour terminer le programme
    }
}
```

1. **`ParameterizedThreadStart`** :
   - La méthode `DownloadFile` est passée au thread via un délégué `ParameterizedThreadStart`, ce qui permet de lui passer un argument (ici une URL sous forme d'objet).

2. **Paramètre du thread** :
   - La méthode `DownloadFile` prend un paramètre de type `object`, qui est ensuite converti en `string` pour l'utiliser comme URL de téléchargement. Cela permet au même code de gérer différentes entrées pour chaque thread.
   
3. **Téléchargements simulés** :
   - Pour chaque URL dans la liste, un nouveau thread est démarré, et l'URL est passée comme paramètre au thread via `Start(url)`.

4. **Simulation de téléchargement** :
   - Le téléchargement est simulé avec `Thread.Sleep(3000)` pour imiter une tâche prenant du temps, comme le téléchargement d'un fichier volumineux.

5. **Parallélisme** :
   - Chaque URL est téléchargée sur un thread séparé, permettant de gérer plusieurs téléchargements simultanément sans bloquer le thread principal.

### Bénéfices de `ParameterizedThreadStart` :
- **Flexibilité** : Vous pouvez passer des données spécifiques à chaque thread.
- **Parallélisme simple** : Facilite l'exécution de plusieurs tâches avec des paramètres différents sans avoir besoin de gérer des variables globales.
- **Clarté** : Les threads sont isolés et exécutent indépendamment la même méthode avec des paramètres personnalisés.

Cette approche est utile dans des scénarios où chaque thread doit travailler avec des données spécifiques tout en effectuant des tâches similaires.


1. **Création d'un thread** :  
   On crée un nouveau thread avec `new Thread(new ThreadStart(TaskToRun));` où `TaskToRun` est la méthode qui sera exécutée dans ce thread.
   
2. **Démarrage du thread** :  
   Le thread est démarré avec la méthode `Start()`.

3. **Pause dans un thread** :  
   La méthode `Thread.Sleep(milliseconds)` permet de suspendre l'exécution du thread pour une durée en millisecondes.

4. **Synchronisation avec `Join()`** :  
   La méthode `Join()` est utilisée pour bloquer le thread principal jusqu'à ce que le thread secondaire ait terminé son exécution.

### Membres importants de la classe `Thread` :

- **`Start()`** : Lance l'exécution du thread.
- **`Join()`** : Bloque l'appelant jusqu'à ce que le thread appelé termine.
- **`Sleep()`** : Suspend l'exécution du thread actuel pour une durée spécifiée.
- **`IsAlive`** : Indique si le thread est en cours d'exécution.
- **`Priority`** : Définit la priorité du thread (Low, Normal, High, etc.).
- **`Abort()`** (obsolète) : Tente d'arrêter le thread de manière forcée.


## 1. **`Start()`** : Démarrage d'un thread pour exécuter une tâche en arrière-plan

#### Scénario : Traitement de fichiers volumineux dans une application
Une application télécharge un fichier volumineux et souhaite traiter ce fichier sans bloquer l'interface utilisateur. On utilise `Thread.Start()` pour traiter le fichier en arrière-plan.

```csharp
using System;
using System.IO;
using System.Threading;

class FileProcessor
{
    static void ProcessFile(string filePath)
    {
        Console.WriteLine($"Début du traitement du fichier {filePath} dans le thread : {Thread.CurrentThread.ManagedThreadId}");
        Thread.Sleep(5000); // Simuler un traitement de 5 secondes
        Console.WriteLine("Traitement du fichier terminé.");
    }

    static void Main()
    {
        string filePath = "fichier_grand.txt";

        // Création d'un thread pour le traitement en arrière-plan
        Thread processingThread = new Thread(() => ProcessFile(filePath));

        Console.WriteLine("Lancement du traitement du fichier...");
        processingThread.Start(); // Démarrage du thread

        Console.WriteLine("L'interface utilisateur reste réactive pendant le traitement.");
        Console.ReadLine();
    }
}
```

## 2. **`Join()`** : Attendre la fin de l'exécution d'un thread

#### Scénario : Génération de rapports après le traitement des données
Une application analyse des données sur plusieurs threads et génère un rapport à la fin. On utilise `Join()` pour s'assurer que tous les threads ont terminé avant de générer le rapport.

```csharp
using System;
using System.Threading;

class DataAnalyzer
{
    static void AnalyzeData(string dataset)
    {
        Console.WriteLine($"Analyse du dataset {dataset} démarrée dans le thread : {Thread.CurrentThread.ManagedThreadId}");
        Thread.Sleep(3000); // Simuler un traitement de données
        Console.WriteLine($"Analyse du dataset {dataset} terminée.");
    }

    static void Main()
    {
        Thread thread1 = new Thread(() => AnalyzeData("Dataset 1"));
        Thread thread2 = new Thread(() => AnalyzeData("Dataset 2"));

        Console.WriteLine("Démarrage de l'analyse des datasets...");
        thread1.Start();
        thread2.Start();

        // Attendre que les deux analyses soient terminées
        thread1.Join();
        thread2.Join();

        Console.WriteLine("Toutes les analyses sont terminées. Génération du rapport...");
        // Génération du rapport
        Console.ReadLine();
    }
}
```

## 3. **`Sleep()`** : Suspendre un thread pendant une durée spécifiée

#### Scénario : Reconnexion périodique à une API après une déconnexion
Une application tente de se reconnecter périodiquement à une API en cas de déconnexion. On utilise `Thread.Sleep()` pour implémenter une temporisation entre chaque tentative.

```csharp
using System;
using System.Threading;

class ApiConnector
{
    static void AttemptReconnection()
    {
        int retries = 5;

        while (retries > 0)
        {
            Console.WriteLine($"Tentative de reconnexion... ({retries} tentatives restantes)");
            bool success = TryReconnectToApi();

            if (success)
            {
                Console.WriteLine("Connexion réussie !");
                return;
            }

            retries--;
            Thread.Sleep(2000); // Attendre 2 secondes avant la prochaine tentative
        }

        Console.WriteLine("Toutes les tentatives ont échoué.");
    }

    static bool TryReconnectToApi()
    {
        // Simuler une tentative de reconnexion
        Random rand = new Random();
        return rand.Next(0, 2) == 0; // Réussite 50% du temps
    }

    static void Main()
    {
        Thread reconnectionThread = new Thread(AttemptReconnection);
        reconnectionThread.Start();
        reconnectionThread.Join(); // Attendre la fin de la tentative de reconnexion
    }
}
```

## 4. **`IsAlive`** : Vérifier si un thread est encore en cours d'exécution

#### Scénario : Suivi de l'état d'une tâche de sauvegarde
Une application effectue une sauvegarde de la base de données sur un thread distinct. Le thread principal peut afficher l'état de cette tâche en temps réel grâce à `IsAlive`.

```csharp
using System;
using System.Threading;

class BackupManager
{
    static void PerformBackup()
    {
        Console.WriteLine("Démarrage de la sauvegarde...");
        Thread.Sleep(8000); // Simuler une sauvegarde longue
        Console.WriteLine("Sauvegarde terminée !");
    }

    static void Main()
    {
        Thread backupThread = new Thread(PerformBackup);
        backupThread.Start();

        while (backupThread.IsAlive)
        {
            Console.WriteLine("La sauvegarde est toujours en cours...");
            Thread.Sleep(1000); // Vérifier l'état toutes les secondes
        }

        Console.WriteLine("La sauvegarde est terminée.");
    }
}
```

## 5. **`Priority`** : Ajuster la priorité d'un thread

#### Scénario : Exécution prioritaire d'une tâche critique dans un système
Dans un système où certaines tâches sont critiques (par exemple, la collecte de données en temps réel), on peut ajuster la priorité des threads avec `Thread.Priority`.

```csharp
using System;
using System.Threading;

class SensorDataCollector
{
    static void CollectSensorData()
    {
        Console.WriteLine($"Collecte des données du capteur dans le thread {Thread.CurrentThread.ManagedThreadId} avec priorité {Thread.CurrentThread.Priority}");
        Thread.Sleep(4000); // Simuler la collecte de données
        Console.WriteLine("Données collectées.");
    }

    static void Main()
    {
        Thread highPriorityThread = new Thread(CollectSensorData)
        {
            Priority = ThreadPriority.Highest
        };

        Thread lowPriorityThread = new Thread(CollectSensorData)
        {
            Priority = ThreadPriority.Lowest
        };

        Console.WriteLine("Démarrage de la collecte des données...");

        // Lancement des deux threads avec différentes priorités
        highPriorityThread.Start();
        lowPriorityThread.Start();

        highPriorityThread.Join();
        lowPriorityThread.Join();

        Console.WriteLine("Collecte de données terminée.");
    }
}
```

## 6. **`Abort()` (obsolète)** : Forcer l'arrêt d'un thread

> **Note** : `Abort()` est désormais obsolète et ne doit pas être utilisée dans les nouvelles applications .NET.


### 6.1 L'alternative à Abort
Très bien ! Si nous restons dans le contexte de la classe `Thread` sans utiliser `Task`, une alternative à `Thread.Abort()` consiste à utiliser un **flag d'annulation** combiné avec des boucles régulières dans le thread. Cela permet au thread de vérifier périodiquement si une annulation a été demandée et d'arrêter proprement son exécution.

Voici comment mettre en place cette approche avec la classe `Thread` :

### Exemple d'implémentation avec un flag d'annulation

#### Scénario : Processus de traitement de données qui peut être annulé

```csharp
using System;
using System.Threading;

class DataProcessor
{
    // Flag pour indiquer si le thread doit s'arrêter
    private static bool _shouldStop = false;

    static void ProcessData()
    {
        Console.WriteLine("Démarrage du traitement des données...");

        for (int i = 1; i <= 10; i++)
        {
            // Vérifier si une annulation a été demandée
            if (_shouldStop)
            {
                Console.WriteLine("Traitement annulé proprement.");
                return;
            }

            // Simuler le traitement d'un lot de données
            Console.WriteLine($"Traitement du lot {i}/10...");
            Thread.Sleep(1000); // Simuler un traitement prenant du temps (1 seconde)
        }

        Console.WriteLine("Traitement terminé avec succès.");
    }

    static void Main()
    {
        // Créer et démarrer un thread pour le traitement
        Thread processingThread = new Thread(ProcessData);
        processingThread.Start();

        // Simuler une attente avant d'annuler le traitement (ex. après 3 secondes)
        Thread.Sleep(3000);
        Console.WriteLine("Annulation demandée par l'utilisateur...");
        
        // Demander l'arrêt du thread
        _shouldStop = true;

        // Attendre la fin du thread pour assurer une sortie propre
        processingThread.Join();

        Console.WriteLine("Programme terminé.");
    }
}
```

### Explication de l'implémentation :

1. **Flag d'annulation (_shouldStop)** :
   - Un flag booléen `_shouldStop` est utilisé pour indiquer au thread s'il doit s'arrêter ou non.
   - Le thread vérifie régulièrement la valeur de ce flag dans sa boucle de travail.

2. **Boucle de traitement avec vérification périodique** :
   - Pendant chaque itération de la boucle de traitement, le thread vérifie si `_shouldStop` est passé à `true`. Si c'est le cas, le thread termine proprement son exécution en sortant de la boucle.

3. **Annulation après un certain délai** :
   - Dans le thread principal, on simule une action utilisateur (ou un événement externe) qui demande l'annulation du thread après 3 secondes avec `Thread.Sleep(3000)` suivi de `_shouldStop = true`.

4. **`Join()` pour une terminaison propre** :
   - La méthode `Join()` est utilisée pour s'assurer que le thread principal attend la fin du thread secondaire avant de continuer l'exécution. Cela permet de s'assurer que le thread a bien terminé son travail avant la sortie de l'application.

### Avantages de cette approche :
- **Contrôle propre** : Au lieu d'un arrêt brutal comme avec `Abort()`, le thread a la possibilité de terminer proprement son travail et de libérer des ressources.
- **Simple à implémenter** : Cette approche est facile à mettre en place sans nécessiter de structures complexes comme les `Tasks`.
- **Évolutivité** : On peut étendre cette approche en implémentant des étapes de nettoyage dans le thread avant de s'arrêter.

Ce modèle offre un contrôle plus fin sur l'exécution du thread tout en restant dans l'univers de la classe `Thread`, sans passer par les `Tasks` ou d'autres abstractions.

Ces exemples démontrent des scénarios réels où les membres de la classe `Thread` peuvent être utiles. 

Toutefois, dans la plupart des cas modernes, il est préférable d'utiliser les **Tasks** ou le **Parallel Processing** 

pour simplifier la gestion de la concurrence et éviter les problèmes liés aux threads bas niveau.
