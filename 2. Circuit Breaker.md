# Le Circuit Breaker

Oui, le **circuit breaker** peut être considéré comme un **design pattern**.

Voici pourquoi :

- Il s'agit d'un **modèle de conception logiciel** utilisé pour améliorer la **résilience** d'une application distribuée, comme un microservice.
- Son objectif principal est de **prévenir les appels répétés** à un service défaillant en interrompant les requêtes tant que le service n'est pas rétabli.
- Le circuit breaker se compose de trois états :
  - **Fermé (Closed)** : les appels passent normalement.
  - **Ouvert (Open)** : les appels sont bloqués, et une exception est renvoyée immédiatement.
  - **Semi-ouvert (Half-open)** : quelques appels passent pour tester si le service est à nouveau fonctionnel.

Ce pattern est très utile dans les architectures microservices pour **éviter la surcharge** de services externes défaillants et ainsi **stabiliser le système**.

## Explication :
- **Closed** : Le circuit est fermé, les appels passent normalement.
- **Open** : Le circuit est ouvert après plusieurs échecs consécutifs, bloquant ainsi les appels.
- **Half-open** : Le circuit teste le service en permettant quelques appels après un délai.
- **Succès** : Si un appel réussi dans l'état Half-open, le circuit se referme.
- **Échec** : Si l'échec persiste dans Half-open, le circuit se ré-ouvre.

Voici les deux états principaux du **Circuit Breaker** résumés :

- **Circuit fermé (Closed)** : 
  - Les appels fonctionnent **normalement**.
  - Le service est **opérationnel**, et les requêtes passent sans être bloquées.

- **Circuit ouvert (Open)** : 
  - Les appels sont **bloqués** immédiatement.
  - Le service est considéré comme **défaillant**, et aucune requête n'est envoyée tant que le service n'a pas été rétabli.

- **Circuit semi Ouvert(Half-open)**
  - Cet état survient après une période d'attente lorsque le circuit est en état ouvert.
  - Il permet à quelques appels de passer pour **tester** si le service est de nouveau fonctionnel.
  - Si les appels **réussissent**, le circuit retourne à l'état **fermé (Closed)**, et le service est considéré comme rétabli.
  - Si les appels **échouent**, le circuit revient à l'état **ouvert (Open)**, et les appels sont de nouveau bloqués.

``` mermaid

      stateDiagram
          [*] --> Closed: Circuit fermé
      
          Closed --> Open: Erreurs répétées (Seuil dépassé)
          Open --> HalfOpen: Temps d'attente (Timeout)
          HalfOpen --> Closed: Succès dans un appel
          HalfOpen --> Open: Échec dans un appel
      
          Open --> [*]: Échec final

```
---

# Implémentation de Circuit Breaker


### Objectif : Implémenter un **Circuit Breaker** avec **Polly** pour protéger une application **ASP.NET Core 8 Web API** contre les défaillances répétées d'un service externe, tout en illustrant son utilité de manière tangible.

### Structure du projet

```
MyWebApi/
│
├── Controllers/
│   └── WeatherController.cs
├── Services/
│   └── IWeatherService.cs
│   └── WeatherService.cs
├── Extensions/
│   └── PollyExtensions.cs
├── Program.cs
└── MyWebApi.csproj
```

### 1. Dépendances dans le fichier `.csproj`

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Polly" Version="7.2.3" />
    <PackageReference Include="Microsoft.Extensions.Http.Polly" Version="7.0.0" />
    <PackageReference Include="Microsoft.Extensions.Logging.Console" Version="7.0.0" />
  </ItemGroup>
</Project>
```

### 2. Création du service **WeatherService**

**IWeatherService.cs** :
```csharp
public interface IWeatherService
{
    Task<string> GetWeatherAsync();
}
```

**WeatherService.cs** :
```csharp
public class WeatherService : IWeatherService
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<WeatherService> _logger;

    public WeatherService(HttpClient httpClient, ILogger<WeatherService> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
    }

    public async Task<string> GetWeatherAsync()
    {
        try
        {
            var response = await _httpClient.GetAsync("https://api.weather.com/v3/weather");
            response.EnsureSuccessStatusCode();
            return await response.Content.ReadAsStringAsync();
        }
        catch (BrokenCircuitException)
        {
            _logger.LogWarning("Le circuit est ouvert, le service est indisponible.");
            return "Le service est temporairement indisponible.";
        }
    }
}
```

### 3. Création d'une extension pour le **Circuit Breaker**

**Extensions/PollyExtensions.cs** :
```csharp
using Polly;

public static class PollyExtensions
{
    public static IAsyncPolicy<HttpResponseMessage> GetCircuitBreakerPolicy(ILogger logger)
    {
        return Policy
            .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
            .CircuitBreakerAsync(
                handledEventsAllowedBeforeBreaking: 3,
                durationOfBreak: TimeSpan.FromSeconds(30),
                onBreak: (result, timespan) =>
                {
                    logger.LogWarning($"Circuit ouvert : Échec dû à {result.Exception?.Message ?? result.Result.StatusCode.ToString()}. Nouvelle tentative dans {timespan.TotalSeconds} secondes.");
                },
                onReset: () =>
                {
                    logger.LogInformation("Circuit réinitialisé : Le service semble à nouveau disponible.");
                },
                onHalfOpen: () =>
                {
                    logger.LogInformation("Circuit semi-ouvert : Test du service.");
                });
    }
}
```

### 4. Configuration de l'API dans **Program.cs**

```csharp
var builder = WebApplication.CreateBuilder(args);

// Configurez la journalisation pour voir les événements du Circuit Breaker
builder.Logging.ClearProviders();
builder.Logging.AddConsole();

var logger = builder.Services.BuildServiceProvider().GetRequiredService<ILogger<Program>>();

builder.Services.AddHttpClient<IWeatherService, WeatherService>()
    .AddPolicyHandler(PollyExtensions.GetCircuitBreakerPolicy(logger));

var app = builder.Build();

app.UseHttpsRedirection();
app.MapControllers();

app.Run();
```

### 5. Contrôleur pour consommer le service

**Controllers/WeatherController.cs** :
```csharp
[ApiController]
[Route("[controller]")]
public class WeatherController : ControllerBase
{
    private readonly IWeatherService _weatherService;

    public WeatherController(IWeatherService weatherService)
    {
        _weatherService = weatherService;
    }

    [HttpGet]
    public async Task<IActionResult> GetWeather()
    {
        var result = await _weatherService.GetWeatherAsync();
        return Ok(result);
    }
}
```

### 6. Tester et voir l'impact du Circuit Breaker

1. **Lancer l'API** et simuler un échec du service en appelant `/weather`.
2. Après **3 erreurs** consécutives (par exemple 401 Unauthorized ou 500 Internal Server Error), le **Circuit Breaker** va :
   - **Ouvrir le circuit** et **bloquer les requêtes** pendant 30 secondes.
   - Pendant cette période, les logs indiqueront que le circuit est ouvert et que le service est temporairement indisponible.
   - Après 30 secondes, il testera le service à nouveau (état semi-ouvert).
3. Les logs et les messages de retour (comme **"Le service est temporairement indisponible"**) permettront de **visualiser l'impact** et de **comprendre la valeur** de la gestion de résilience.

### Points clés de l'implémentation :

- **Logs visibles** : Les événements du **Circuit Breaker** (ouverture, fermeture, état semi-ouvert) sont clairement enregistrés pour permettre de **voir le comportement** en action.
- **Réponse utilisateur claire** : Lorsque le **circuit est ouvert**, l'utilisateur reçoit un message clair que le service est temporairement indisponible, ce qui améliore l'expérience utilisateur.
- **Protéger contre les appels répétitifs** : Le **Circuit Breaker** empêche les appels inutiles à un service défaillant, protégeant ainsi votre application contre une surcharge.


Cette version de l'exemple montre non seulement comment implémenter un **Circuit Breaker**, mais surtout **pourquoi** il est utile. Vous pouvez observer son impact directement, et la configuration est optimisée pour démontrer sa valeur ajoutée en termes de résilience et de gestion des erreurs.

