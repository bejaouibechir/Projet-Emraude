# Le Circuit Breaker

Oui, le **circuit breaker** peut être considéré comme un **design pattern**.

Voici pourquoi :

- Il s'agit d'un **modèle de conception logiciel** utilisé pour améliorer la **résilience** d'une application distribuée, comme un microservice.
- Son objectif principal est de **prévenir les appels répétés** à un service défaillant en interrompant les requêtes tant que le service n'est pas rétabli.
- Le circuit breaker se compose de trois états :
  - **Fermé (Closed)** : les appels passent normalement.
  - **Ouvert (Open)** : les appels sont bloqués, et une exception est renvoyée immédiatement.
  - **Semi-ouvert (Half-open)** : quelques appels passent pour tester si le service est à nouveau fonctionnel.

Ce pattern est très utile dans les architectures microservices pour **éviter la surcharge** de services externes défaillants et ainsi **stabiliser le système**.

## Explication :
- **Closed** : Le circuit est fermé, les appels passent normalement.
- **Open** : Le circuit est ouvert après plusieurs échecs consécutifs, bloquant ainsi les appels.
- **Half-open** : Le circuit teste le service en permettant quelques appels après un délai.
- **Succès** : Si un appel réussi dans l'état Half-open, le circuit se referme.
- **Échec** : Si l'échec persiste dans Half-open, le circuit se ré-ouvre.


``` mermaid

      stateDiagram
          [*] --> Closed: Circuit fermé
      
          Closed --> Open: Erreurs répétées (Seuil dépassé)
          Open --> HalfOpen: Temps d'attente (Timeout)
          HalfOpen --> Closed: Succès dans un appel
          HalfOpen --> Open: Échec dans un appel
      
          Open --> [*]: Échec final

```

Voici un schéma en mermaid qui exprime les notions du **Circuit Breaker** que j'ai mentionnées :


