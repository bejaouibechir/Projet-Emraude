# Création de TransactionsService en tant que MicroService

Pour dockeriser votre microservice `TransactionsService`, vous allez créer un fichier Dockerfile pour définir l'image Docker de votre application, et un fichier docker-compose.yml pour orchestrer le démarrage de votre application et de ses dépendances, comme la base de données SQL Server.

Voici une démarche détaillée pour dockeriser votre microservice :

Note: Un détail important avant de commencer, si une instance sql server est en courau niveau du Hôte et pour éviter le conflit de ports soit 
- Désactiver l'instance locale
- Changer le port d'écoute au niveau du fichier docker compose

### 1. Dockerfile

Créez un fichier nommé `Dockerfile` à la racine de votre projet `TransactionsService`. Ce fichier définira l'image Docker pour votre application.

```dockerfile

# Utiliser l'image officielle .NET pour la construction (SDK)
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build-env
WORKDIR /app

# Copier les fichiers CSPROJ et restaurer les dépendances
COPY *.csproj ./
RUN dotnet restore

# Copier le reste des fichiers et compiler
COPY . ./
RUN dotnet publish -c Release -o out

# Utiliser l'image officielle .NET pour l'exécution (runtime)
FROM mcr.microsoft.com/dotnet/aspnet:8.0
WORKDIR /app
COPY --from=build-env /app/out .

# Exposer le port 80 pour le serveur web
EXPOSE 80

# Définir le point d'entrée de l'application
ENTRYPOINT ["dotnet", "TransactionsService.dll"]
```

### 2. docker-compose.yml

Créez un fichier nommé `docker-compose.yml` à la racine de votre projet. Ce fichier définira les services pour votre application et sa base de données SQL Server.

```yaml
version: '3.8'

services:
  sqlserver:
    image: mcr.microsoft.com/mssql/server:2022-latest
    container_name: sqlserver
    environment:
      SA_PASSWORD: "Password@1234!"
      ACCEPT_EULA: "Y"
    ports:
      - "1434:1433"
    volumes:
      - sqlserverdata:/var/opt/mssql

  transactionsservice:
    image: transactionsservice
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "5000:80"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ConnectionStrings__BankingDbContext=Server=sqlserver;Database=TransactionsDB;User Id=sa;Password=Password@1234!;
    depends_on:
      - sqlserver

volumes:
  sqlserverdata:
```

### 3. Modifier `appsettings.json`

Assurez-vous que votre `appsettings.json` supporte les variables d'environnement pour la chaîne de connexion. Voici un exemple modifié :

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "BankingDbContext": "Server=localhost,1433;Database=TransactionsDB;User Id=sa;Password=Password@1234!;"
  }
}
```

### 4. Construire et Exécuter les Conteneurs

Dans un terminal, naviguez à la racine de votre projet et exécutez les commandes suivantes :

```sh
# Construire l'image Docker
docker-compose build

# Démarrer les conteneurs
docker-compose up
```

Ces commandes vont construire l'image Docker pour votre microservice, démarrer un conteneur SQL Server, et démarrer votre microservice connecté à la base de données.

### 5. Vérifier le Fonctionnement

Après avoir exécuté `docker-compose up`, votre microservice devrait être accessible sur `http://localhost:5000`. Vous pouvez utiliser des outils comme Postman pour tester vos endpoints de dépôt et de retrait.

### Notes Additionnelles

- Assurez-vous que votre serveur SQL Server est correctement configuré et accessible.
- Vous pouvez personnaliser le mot de passe et d'autres paramètres selon vos besoins.
- Les noms de services et ports peuvent être ajustés selon votre environnement de développement.

En suivant ces étapes, vous devriez être en mesure de dockeriser votre microservice `TransactionsService` et de le faire fonctionner dans un environnement conteneurisé.
