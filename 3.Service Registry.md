# 3. Le Service Registry

Le **Service Registry** n'est pas un design pattern au sens traditionnel, mais plutôt un **composant architectural** ou un **pattern d'infrastructure** utilisé dans les systèmes distribués comme les microservices.

Voici les points clés à retenir :

- Il s'agit d'un **registre centralisé** où les services microservices s'enregistrent pour rendre leur localisation disponible.
- Le **Service Discovery** est un processus lié, permettant aux autres services de **découvrir dynamiquement** l'emplacement des services disponibles.
- Cela est essentiel dans une architecture où les services peuvent **changer d'adresse IP** (par exemple, en raison du scaling ou du déplacement entre les serveurs).
  
Bien que le **Service Registry** ne soit pas un design pattern classique comme le **Singleton** ou **Factory**, il est plutôt une **composante essentielle** dans l'architecture des microservices
pour assurer la **découverte dynamique** et la **résilience** du système.

### Eureka Server :
- Le **Eureka Server** (Service Registry) est au centre du système. Il stocke les informations des services enregistrés, ici deux instances de **WeatherService**.
- Chaque instance de **WeatherService** s'enregistre dynamiquement dans le **Service Registry**.
- La **Client Application** effectue une **découverte de service** auprès d'Eureka pour trouver les instances disponibles de **WeatherService**.
- Le client, après avoir découvert les instances, peut interagir directement avec l'une des instances de **WeatherService**.

Ce schéma montre comment le **Service Registry** permet aux clients de trouver et d'interagir dynamiquement avec les services enregistrés, sans avoir à connaître leurs adresses IP ou ports exacts.



### Le mécanisme :

1. **Register** : Les instances de **WeatherService** s'enregistrent dans le **Service Registry (Eureka)**.
2. **Service Discovery Request** : L'application cliente envoie une requête de découverte au **Service Registry (Eureka)** pour obtenir les informations des services disponibles.
3. **Return Service Instance Info** : Eureka renvoie les informations des instances de **WeatherService** enregistrées (comme leurs adresses IP et ports) à l'application cliente.
4. **Call Service** : L'application cliente peut maintenant appeler dynamiquement l'une des instances de **WeatherService**.

``` mermaid
    sequenceDiagram
        participant Client as Client Application
        participant Eureka as Service Registry (Eureka)
        participant WS1 as WeatherService Instance 1
        participant WS2 as WeatherService Instance 2
    
        WS1 ->> Eureka: 1. Register WeatherService Instance 1
        WS2 ->> Eureka: 1. Register WeatherService Instance 2
        Client ->> Eureka: 2. Service Discovery Request (WeatherService)
        Eureka ->> Client: 3. Return Service Instance Info (Instance 1, Instance 2)
        Client ->> WS1: 4. Call WeatherService Instance 1
```


--- 

# Exemple d'implémentation de Service Registry

D'accord, voici une version améliorée de la démonstration qui prend en compte plusieurs instances du même service **WeatherService**. Cette version inclut l'enregistrement de **plusieurs instances**, la découverte dynamique par un client, et un **équilibrage de charge** automatique entre les différentes instances.

### 1. Structure du projet

```
ServiceRegistryDemo/
│
├── Services/
│   └── IWeatherService.cs
│   └── WeatherService.cs
├── Controllers/
│   └── WeatherController.cs
├── Program.cs
├── appsettings.json
└── ServiceRegistryDemo.csproj
```

### 2. Dépendances

Modifiez le fichier `.csproj` pour inclure les packages nécessaires, dont **Steeltoe** pour la gestion de **Eureka** et la découverte des services.

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Steeltoe.Discovery.ClientCore" Version="3.2.2" />
    <PackageReference Include="Steeltoe.Common.Http" Version="3.2.2" />
    <PackageReference Include="Microsoft.Extensions.Http" Version="7.0.0" />
  </ItemGroup>
</Project>
```

### 3. Configuration d'Eureka dans `appsettings.json`

Configurez **Eureka** pour gérer plusieurs instances en définissant des informations comme le nom du service et le port pour chaque instance.

**appsettings.json** :
```json
{
  "spring": {
    "application": {
      "name": "WeatherService"
    }
  },
  "eureka": {
    "client": {
      "serviceUrl": "http://localhost:8761/eureka/"
    },
    "instance": {
      "appName": "WeatherService",
      "instanceId": "WeatherServiceInstance-${random.value}",
      "port": 0  // Port aléatoire pour simuler plusieurs instances
    }
  }
}
```
### 4. Program.cs : Enregistrement et découverte dynamique avec plusieurs instances

Modifiez le **Program.cs** pour inclure la gestion de la découverte de service avec Eureka et l'ajout de **plusieurs instances**.

```csharp
var builder = WebApplication.CreateBuilder(args);

// Configuration du service registry Eureka pour la découverte et l'enregistrement
builder.Services.AddDiscoveryClient(builder.Configuration);

// Configuration de HttpClient avec Steeltoe pour la découverte dynamique
builder.Services.AddHttpClient<IWeatherService, WeatherService>()
    .AddServiceDiscovery();

// Configurer l'API
var app = builder.Build();

app.UseHttpsRedirection();
app.MapControllers();
app.UseDiscoveryClient(); // Utilise Eureka pour découvrir les services

app.Run();
```

### 5. Création du service WeatherService

Ajoutons le service **WeatherService** avec plusieurs instances enregistrées dans **Eureka**.

**Services/IWeatherService.cs** :
```csharp
public interface IWeatherService
{
    Task<string> GetWeatherAsync();
}
```

**Services/WeatherService.cs** :
```csharp
public class WeatherService : IWeatherService
{
    private readonly HttpClient _httpClient;

    public WeatherService(HttpClient httpClient)
    {
        _httpClient = httpClient;
    }

    public async Task<string> GetWeatherAsync()
    {
        var response = await _httpClient.GetAsync("http://WeatherService/weather");
        response.EnsureSuccessStatusCode();
        return await response.Content.ReadAsStringAsync();
    }
}
```

### 6. Contrôleur WeatherController pour consommer le service

**Controllers/WeatherController.cs** :
```csharp
[ApiController]
[Route("[controller]")]
public class WeatherController : ControllerBase
{
    private readonly IWeatherService _weatherService;

    public WeatherController(IWeatherService weatherService)
    {
        _weatherService = weatherService;
    }

    [HttpGet]
    public async Task<IActionResult> GetWeather()
    {
        var result = await _weatherService.GetWeatherAsync();
        return Ok(result);
    }
}
```

### 7. Démarrage de plusieurs instances

Pour simuler plusieurs instances du même service, vous devez lancer plusieurs instances de l'application **ServiceRegistryDemo** sur des ports différents.

- Lancez la première instance en utilisant un port aléatoire ou un port spécifique :
  
  ```bash
  dotnet run --urls="http://localhost:5001"
  ```

- Lancez une deuxième instance sur un autre port :

  ```bash
  dotnet run --urls="http://localhost:5002"
  ```

- Vous pouvez également simuler plus d'instances de la même manière.

### 8. Lancer un serveur Eureka

Vous devez avoir un serveur **Eureka** fonctionnel pour gérer le registre des services. Si ce n'est pas déjà fait, vous pouvez lancer un serveur **Eureka** avec Docker.

```bash
docker run -d -p 8761:8761 steeltoeoss/eureka-server
```

Cela démarre un serveur Eureka sur `http://localhost:8761`.

### 9. Test avec plusieurs instances enregistrées

1. **Accédez à l'interface Eureka** : Allez à `http://localhost:8761` pour voir l'interface d'Eureka. Vous devriez y voir plusieurs instances de **WeatherService** enregistrées sous le même nom.
   
2. **Accédez à l'API `/weather`** : Lorsque l'application cliente envoie une requête de découverte, elle obtiendra les informations de toutes les instances de **WeatherService** enregistrées dans Eureka.

3. **Load balancing** : Grâce à **Steeltoe**, la requête peut être répartie entre les différentes instances de **WeatherService** automatiquement. Par exemple, si vous avez 3 instances de **WeatherService**, la requête client peut être redirigée vers l'une d'elles de manière équilibrée.

### Fonctionnalité mise en valeur :

- **Découverte dynamique avec plusieurs instances** : Les multiples instances de **WeatherService** s'enregistrent dynamiquement dans Eureka, et le client peut découvrir ces instances sans connaître leurs adresses.
- **Load balancing** : Le **client** ne connaît pas les adresses des instances spécifiques, mais peut appeler le service de manière transparente, et les requêtes sont distribuées entre les différentes instances disponibles.
- **Tolérance aux pannes** : Si une instance tombe en panne, Eureka met à jour le registre et l'application cliente ne tentera plus d'appeler cette instance, réduisant ainsi les risques d'erreurs.

### Conclusion

Cette démonstration montre comment plusieurs instances d'un service peuvent être enregistrées dans un **Service Registry** comme **Eureka**, et comment un client peut **découvrir** et **équilibrer les appels** dynamiquement entre ces instances, garantissant **flexibilité** et **résilience** dans une architecture de microservices.
