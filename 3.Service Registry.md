# 3. Le Service Registry

Le **Service Registry** n'est pas un design pattern au sens traditionnel, mais plutôt un **composant architectural** ou un **pattern d'infrastructure** utilisé dans les systèmes distribués comme les microservices.

Voici les points clés à retenir :

- Il s'agit d'un **registre centralisé** où les services microservices s'enregistrent pour rendre leur localisation disponible.
- Le **Service Discovery** est un processus lié, permettant aux autres services de **découvrir dynamiquement** l'emplacement des services disponibles.
- Cela est essentiel dans une architecture où les services peuvent **changer d'adresse IP** (par exemple, en raison du scaling ou du déplacement entre les serveurs).
  
Bien que le **Service Registry** ne soit pas un design pattern classique comme le **Singleton** ou **Factory**, il est plutôt une **composante essentielle** dans l'architecture des microservices
pour assurer la **découverte dynamique** et la **résilience** du système.

### Eureka Server :
- Le **Eureka Server** (Service Registry) est au centre du système. Il stocke les informations des services enregistrés, ici deux instances de **WeatherService**.
- Chaque instance de **WeatherService** s'enregistre dynamiquement dans le **Service Registry**.
- La **Client Application** effectue une **découverte de service** auprès d'Eureka pour trouver les instances disponibles de **WeatherService**.
- Le client, après avoir découvert les instances, peut interagir directement avec l'une des instances de **WeatherService**.

Ce schéma montre comment le **Service Registry** permet aux clients de trouver et d'interagir dynamiquement avec les services enregistrés, sans avoir à connaître leurs adresses IP ou ports exacts.



### Le mécanisme :

1. **Register** : Les instances de **WeatherService** s'enregistrent dans le **Service Registry (Eureka)**.
2. **Service Discovery Request** : L'application cliente envoie une requête de découverte au **Service Registry (Eureka)** pour obtenir les informations des services disponibles.
3. **Return Service Instance Info** : Eureka renvoie les informations des instances de **WeatherService** enregistrées (comme leurs adresses IP et ports) à l'application cliente.
4. **Call Service** : L'application cliente peut maintenant appeler dynamiquement l'une des instances de **WeatherService**.

``` mermaid
    sequenceDiagram
        participant Client as Client Application
        participant Eureka as Service Registry (Eureka)
        participant WS1 as WeatherService Instance 1
        participant WS2 as WeatherService Instance 2
    
        WS1 ->> Eureka: 1. Register WeatherService Instance 1
        WS2 ->> Eureka: 1. Register WeatherService Instance 2
        Client ->> Eureka: 2. Service Discovery Request (WeatherService)
        Eureka ->> Client: 3. Return Service Instance Info (Instance 1, Instance 2)
        Client ->> WS1: 4. Call WeatherService Instance 1
```


--- 

# Exemple d'implémentation de Service Registry

Bien sûr, passons maintenant à une démonstration d'un **Service Registry** dans une architecture de microservices. Le **Service Registry** est une composante essentielle qui permet aux microservices de **s'enregistrer dynamiquement** et de **découvrir** les autres services sans avoir à connaître leurs adresses IP fixes, ce qui est crucial dans les environnements où les services peuvent être **scalés**, **déplacés** ou **redémarrés**.

### Objectif : Implémenter un **Service Registry** avec **Eureka** dans un projet **ASP.NET Core 8 Web API** et montrer comment un service peut s'enregistrer, se découvrir et se consommer dynamiquement, démontrant ainsi une flexibilité dans une architecture de microservices.

Nous allons utiliser **Steeltoe** avec **Eureka**, une solution populaire pour la gestion du **Service Registry** dans l'écosystème .NET.

### 1. Structure du projet

```
ServiceRegistryDemo/
│
├── Services/
│   └── IWeatherService.cs
│   └── WeatherService.cs
├── Controllers/
│   └── WeatherController.cs
├── Program.cs
└── ServiceRegistryDemo.csproj
```

### 2. Dépendances

Ajoutons les packages nécessaires dans le fichier `.csproj` :

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Steeltoe.Discovery.ClientCore" Version="3.2.2" />
    <PackageReference Include="Steeltoe.Common.Http" Version="3.2.2" />
    <PackageReference Include="Microsoft.Extensions.Http" Version="7.0.0" />
  </ItemGroup>
</Project>
```

### 3. Configurer Eureka dans `appsettings.json`

Eureka est utilisé comme **Service Registry** dans cet exemple. Vous devez configurer **Eureka** dans votre fichier `appsettings.json` pour vous connecter au serveur Eureka.

**appsettings.json** :

```json
{
  "spring": {
    "application": {
      "name": "WeatherService"
    }
  },
  "eureka": {
    "client": {
      "serviceUrl": "http://localhost:8761/eureka/"
    },
    "instance": {
      "appName": "WeatherService",
      "port": 8080
    }
  }
}
```

### 4. Implémentation du Service Registry dans **Program.cs**

**Program.cs** :

```csharp
var builder = WebApplication.CreateBuilder(args);

// Ajouter Eureka pour l'enregistrement et la découverte de services
builder.Services.AddDiscoveryClient(builder.Configuration);

// Ajouter HttpClient avec support pour la découverte de services
builder.Services.AddHttpClient<IWeatherService, WeatherService>()
    .AddServiceDiscovery();

// Configurer l'API
var app = builder.Build();

app.UseHttpsRedirection();
app.MapControllers();
app.UseDiscoveryClient(); // Utiliser Eureka pour découvrir les services

app.Run();
```

### 5. Service de météo avec découverte dynamique

**Services/IWeatherService.cs** :
```csharp
public interface IWeatherService
{
    Task<string> GetWeatherAsync();
}
```

**Services/WeatherService.cs** :
```csharp
public class WeatherService : IWeatherService
{
    private readonly HttpClient _httpClient;

    public WeatherService(HttpClient httpClient)
    {
        _httpClient = httpClient;
    }

    public async Task<string> GetWeatherAsync()
    {
        // Le client découvre dynamiquement le service WeatherService via Eureka
        var response = await _httpClient.GetAsync("http://WeatherService/weather");
        response.EnsureSuccessStatusCode();
        return await response.Content.ReadAsStringAsync();
    }
}
```

### 6. Contrôleur pour consommer le service

**Controllers/WeatherController.cs** :
```csharp
[ApiController]
[Route("[controller]")]
public class WeatherController : ControllerBase
{
    private readonly IWeatherService _weatherService;

    public WeatherController(IWeatherService weatherService)
    {
        _weatherService = weatherService;
    }

    [HttpGet]
    public async Task<IActionResult> GetWeather()
    {
        var result = await _weatherService.GetWeatherAsync();
        return Ok(result);
    }
}
```

### 7. Lancement d'un serveur Eureka

Avant de tester, vous devez avoir un **serveur Eureka** en cours d'exécution pour gérer le **Service Registry**.

Vous pouvez démarrer un serveur Eureka en utilisant **Spring Cloud Eureka Server** ou en utilisant une image Docker.

```bash
docker run -d -p 8761:8761 steeltoeoss/eureka-server
```

Cela démarre un serveur Eureka à l'adresse `http://localhost:8761` qui gérera l'enregistrement des services.

### 8. Test de la découverte de services et de l'utilité du **Service Registry**

1. **Lancer le serveur Eureka** et démarrer votre application **ServiceRegistryDemo**.
2. Allez à `http://localhost:8761` pour voir l'interface Eureka. Vous devriez voir que votre **WeatherService** s'est enregistré dynamiquement dans Eureka sous le nom **WeatherService**.
3. Accédez à l'API `/weather` à partir de votre service Web. Grâce à **Steeltoe** et **Eureka**, les appels au service **WeatherService** sont résolus dynamiquement sans que vous ayez à coder une adresse IP fixe ou un port.

### Fonctionnalité remarquée du **Service Registry** :

1. **Découverte dynamique** : Vous n'avez pas à spécifier les adresses IP ou les ports des services individuellement. Eureka permet de **localiser dynamiquement** les services.
2. **Évolutivité et résilience** : Lorsque vous scalez le service (par exemple, plusieurs instances de **WeatherService**), Eureka gère l'enregistrement de toutes les instances. Votre client peut automatiquement équilibrer la charge entre plusieurs instances sans configuration supplémentaire.
3. **Tolérance aux pannes** : Si une instance du service tombe en panne, Eureka met à jour son registre pour exclure cette instance, et les autres services peuvent continuer à fonctionner en utilisant les instances restantes.

### Conclusion

L'utilisation d'un **Service Registry** comme **Eureka** permet une **découverte dynamique** et une gestion efficace des microservices, en particulier dans les environnements où les adresses IP des services changent fréquemment ou lorsqu'il y a des défaillances. Cela apporte une **grande flexibilité** et **évolutivité** sans avoir à gérer manuellement les configurations de service. 

Ainsi, vous pouvez facilement voir l'impact direct de la **découverte dynamique** dans les scénarios de production, où les microservices doivent interagir de manière fluide même lorsque l'infrastructure change en arrière-plan.








