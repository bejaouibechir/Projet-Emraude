# Kubernetes (Vue d'ensemble) 

## Schema illustratif de l'architecture Kubernetes

Bien sûr ! Voici un schéma Mermaid qui représente les composants principaux de Kubernetes :

```mermaid
graph TD
    subgraph Cluster
        direction TB

        subgraph ControlPlane
            CP_API[API Server]
            CP_Scheduler[Scheduler]
            CP_ControllerManager[Controller Manager]
            CP_ETCD[etcd]
        end

        subgraph Node1
            N1_Kubelet[Kubelet]
            N1_KubeProxy[Kube-Proxy]
            N1_Pods[Pods]
        end

        subgraph Node2
            N2_Kubelet[Kubelet]
            N2_KubeProxy[Kube-Proxy]
            N2_Pods[Pods]
        end

        subgraph NodeN
            Nn_Kubelet[Kubelet]
            Nn_KubeProxy[Kube-Proxy]
            Nn_Pods[Pods]
        end

        CP_API -->|Communicates with| CP_Scheduler
        CP_API -->|Communicates with| CP_ControllerManager
        CP_Scheduler -->|Stores in| CP_ETCD
        CP_ControllerManager -->|Stores in| CP_ETCD

        CP_API -->|Manages| N1_Kubelet
        CP_API -->|Manages| N2_Kubelet
        CP_API -->|Manages| Nn_Kubelet

        N1_Kubelet --> N1_Pods
        N2_Kubelet --> N2_Pods
        Nn_Kubelet --> Nn_Pods

        N1_KubeProxy -->|Network Communication| N1_Pods
        N2_KubeProxy -->|Network Communication| N2_Pods
        Nn_KubeProxy -->|Network Communication| Nn_Pods
    end
```

### Explications du Schéma :

- **Control Plane** : Composants du plan de contrôle de Kubernetes :
  - **API Server** : Expose l'API Kubernetes.
  - **Scheduler** : Planifie les pods sur les nœuds.
  - **Controller Manager** : Gère les contrôleurs de Kubernetes.
  - **etcd** : Stockage clé-valeur distribué pour la configuration.

- **Nodes (Nœuds)** : Composants des nœuds de travail :
  - **Kubelet** : Agent qui s'assure que les conteneurs sont en cours d'exécution dans un pod.
  - **Kube-Proxy** : Gère le routage des services.
  - **Pods** : Unités d'exécution des applications, contenant un ou plusieurs conteneurs.

- **Communication** :
  - Le **API Server** communique avec les **Kubelets** sur les nœuds pour gérer les pods.
  - Le **Scheduler** et le **Controller Manager** utilisent **etcd** pour stocker et récupérer l'état des ressources.
  - Le **Kube-Proxy** assure la communication réseau entre les pods.

## La liste des objets K8s utilisés pour créer un système orchestré

Voici une vue d'ensemble des principaux objets Kubernetes, accompagnés de schémas Mermaid pour illustrer chaque objet ainsi que deux méthodes pour les créer : via un fichier manifest et directement avec la commande `kubectl`.

### 1. **Pod**

Un Pod est l'unité de base dans Kubernetes qui regroupe un ou plusieurs conteneurs.

#### Schéma Mermaid

```mermaid
graph TD
    Pod[Pod]
    Container1[Container 1]
    Container2[Container 2]

    Pod --> Container1
    Pod --> Container2
```

#### Création avec un fichier manifest

**`pod.yaml`**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
  - name: my-container
    image: my-image
```

#### Création avec `kubectl`

```bash
kubectl run my-pod --image=my-image
```

### 2. **Service**

Un Service expose un ensemble de Pods comme un service réseau.

#### Schéma Mermaid

```mermaid
graph TD
    Service[Service]
    Pod1[Pod 1]
    Pod2[Pod 2]
    Pod3[Pod 3]

    Service --> Pod1
    Service --> Pod2
    Service --> Pod3
```

#### Création avec un fichier manifest

**`service.yaml`**
```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: my-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
```

#### Création avec `kubectl`

```bash
kubectl expose pod my-pod --port=80 --target-port=8080 --name=my-service
```

### 3. **Deployment**

Un Deployment gère le déploiement et la mise à jour des Pods et de leurs réplicas.

#### Schéma Mermaid

```mermaid
graph TD
    Deployment[Deployment]
    Pod1[Pod 1]
    Pod2[Pod 2]
    Pod3[Pod 3]

    Deployment --> Pod1
    Deployment --> Pod2
    Deployment --> Pod3
```

#### Création avec un fichier manifest

**`deployment.yaml`**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-container
        image: my-image
```

#### Création avec `kubectl`

```bash
kubectl create deployment my-deployment --image=my-image --replicas=3
```

### 4. **ReplicaSet**

Un ReplicaSet garantit que le nombre spécifié de réplicas d'un Pod est en cours d'exécution.

#### Schéma Mermaid

```mermaid
graph TD
    ReplicaSet[ReplicaSet]
    Pod1[Pod 1]
    Pod2[Pod 2]
    Pod3[Pod 3]

    ReplicaSet --> Pod1
    ReplicaSet --> Pod2
    ReplicaSet --> Pod3
```

#### Création avec un fichier manifest

**`replicaset.yaml`**
```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: my-replicaset
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-container
        image: my-image
```

#### Création avec `kubectl`

```bash
kubectl create replicaset my-replicaset --image=my-image --replicas=3
```

### 5. **StatefulSet**

Un StatefulSet gère les déploiements de Pods avec des identités stables et un stockage persistant.

#### Schéma Mermaid

```mermaid
graph TD
    StatefulSet[StatefulSet]
    Pod1[Pod 1]
    Pod2[Pod 2]
    Pod3[Pod 3]

    StatefulSet --> Pod1
    StatefulSet --> Pod2
    StatefulSet --> Pod3
```

#### Création avec un fichier manifest

**`statefulset.yaml`**
```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: my-statefulset
spec:
  serviceName: "my-service"
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-container
        image: my-image
  volumeClaimTemplates:
  - metadata:
      name: my-persistent-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 1Gi
```

#### Création avec `kubectl`

```bash
kubectl create statefulset my-statefulset --image=my-image --replicas=3
```

### 6. **DaemonSet**

Un DaemonSet assure que chaque nœud exécute une copie d'un Pod.

#### Schéma Mermaid

```mermaid
graph TD
    DaemonSet[DaemonSet]
    Node1[Node 1]
    Node2[Node 2]
    Node3[Node 3]
    Pod[Pod]

    DaemonSet --> Node1
    DaemonSet --> Node2
    DaemonSet --> Node3
    Node1 --> Pod
    Node2 --> Pod
    Node3 --> Pod
```

#### Création avec un fichier manifest

**`daemonset.yaml`**
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: my-daemonset
spec:
  selector:
    matchLabels:
      name: my-daemonset
  template:
    metadata:
      labels:
        name: my-daemonset
    spec:
      containers:
      - name: my-container
        image: my-image
```

#### Création avec `kubectl`

```bash
kubectl create daemonset my-daemonset --image=my-image
```

### 7. **Job**

Un Job exécute un ou plusieurs Pods jusqu'à ce qu'ils complètent leur tâche.

#### Schéma Mermaid

```mermaid
graph TD
    Job[Job]
    Pod1[Pod 1]
    Pod2[Pod 2]

    Job --> Pod1
    Job --> Pod2
```

#### Création avec un fichier manifest

**`job.yaml`**
```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: my-job
spec:
  template:
    spec:
      containers:
      - name: my-container
        image: my-image
      restartPolicy: Never
```

#### Création avec `kubectl`

```bash
kubectl create job my-job --image=my-image
```

### 8. **CronJob**

Un CronJob exécute des Jobs périodiquement selon une planification.

#### Schéma Mermaid

```mermaid
graph TD
    CronJob[CronJob]
    Job[Job]
    Pod1[Pod 1]
    Pod2[Pod 2]

    CronJob --> Job
    Job --> Pod1
    Job --> Pod2
```

#### Création avec un fichier manifest

**`cronjob.yaml`**
```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: my-cronjob
spec:
  schedule: "*/5 * * * *"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: my-container
            image: my-image
          restartPolicy: OnFailure
```

#### Création avec `kubectl`

```bash
kubectl create cronjob my-cronjob --image=my-image --schedule="*/5 * * * *"
```

### 9. **ConfigMap**

Un ConfigMap stocke des données de configuration non sensibles utilisées par les Pods.

#### Schéma Mermaid

```mermaid
graph TD
    ConfigMap[ConfigMap]
    Pod[Pod]
    Key1[Key 1]
    Key2[Key 2]

    ConfigMap --> Key1
    ConfigMap --> Key2
    Pod --> ConfigMap
```

#### Création avec un fichier manifest

**`configmap.yaml`**
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-configmap
data:
  key1: value1
  key2: value2
```

#### Création avec `kubectl`

```bash
kubectl create configmap my-configmap --from-literal=key1=value1 --from-literal=key2=value2
```

### 10. **Secret**

Un Secret stocke des données sensibles comme les mots de passe et les clés d'API.

#### Schéma Mermaid

```mermaid
graph TD
    Secret[Secret]
    Pod[Pod]
    Data1[Data 1]
    Data2[Data 2]

    Secret --> Data1
    Secret --> Data2
    Pod --> Secret
```

#### Création avec un fichier manifest

**`secret.yaml`**
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-secret
type: Opaque
data:
  key1: base64encodedvalue1
  key2: base64encoded

value2
```

#### Création avec `kubectl`

```bash
kubectl create secret generic my-secret --from-literal=key1=value1 --from-literal=key2=value2
```

### 11. **Namespace**

Un Namespace est un espace de noms logique dans un cluster Kubernetes, utilisé pour isoler les ressources.

#### Schéma Mermaid

```mermaid
graph TD
    Namespace[Namespace]
    Pod1[Pod 1]
    Pod2[Pod 2]
    Service[Service]

    Namespace --> Pod1
    Namespace --> Pod2
    Namespace --> Service
```

#### Création avec un fichier manifest

**`namespace.yaml`**
```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: my-namespace
```

#### Création avec `kubectl`

```bash
kubectl create namespace my-namespace
```

### 12. **Ingress**

Un Ingress gère l'accès externe aux services dans un cluster Kubernetes.

#### Schéma Mermaid

```mermaid
graph TD
    Ingress[Ingress]
    Service[Service]
    ExternalUser[External User]

    Ingress --> Service
    ExternalUser --> Ingress
```

#### Création avec un fichier manifest

**`ingress.yaml`**
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
spec:
  rules:
  - host: my-app.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: my-service
            port:
              number: 80
```

#### Création avec `kubectl`

```bash
kubectl create ingress my-ingress --rule="host=my-app.example.com,path=/,serviceName=my-service,servicePort=80"
```

### 13. **NetworkPolicy**

Un NetworkPolicy contrôle le trafic réseau vers et depuis les Pods.

#### Schéma Mermaid

```mermaid
graph TD
    NetworkPolicy[NetworkPolicy]
    Pod[Pod]
    Allow[Allow]
    Deny[Deny]

    NetworkPolicy --> Allow
    NetworkPolicy --> Deny
    Pod --> NetworkPolicy
```

#### Création avec un fichier manifest

**`networkpolicy.yaml`**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: my-networkpolicy
spec:
  podSelector:
    matchLabels:
      app: my-app
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: other-app
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: other-app
```

#### Création avec `kubectl`

```bash
kubectl create networkpolicy my-networkpolicy --pod-selector=app=my-app --ingress-from=podSelector=app=other-app --egress-to=podSelector=app=other-app
```

Ces exemples couvrent les principaux objets Kubernetes et montrent comment les créer à la fois avec des fichiers manifest et directement via la ligne de commande `kubectl`.
