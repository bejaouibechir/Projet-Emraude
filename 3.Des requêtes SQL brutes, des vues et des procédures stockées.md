# Travailler avec des requêtes SQL brutes, des vues et des procédures stockées

Entity Framework (EF) permet de travailler avec des requêtes SQL brutes, des vues et des procédures stockées tout en continuant à bénéficier des avantages de l'ORM. Voici comment vous pouvez utiliser ces fonctionnalités avec des fragments de code en C#.

### 1. **Requêtes SQL brutes**

Les requêtes SQL brutes peuvent être exécutées directement dans Entity Framework à l'aide de la méthode `FromSqlRaw` ou `FromSqlInterpolated` (à partir d'EF Core 3.0). Cela permet d'exécuter des requêtes SQL directement tout en mappant les résultats à des entités ou des modèles.

**Exemple : Exécution d'une requête SQL brute**
```csharp
// Requête avec FromSqlRaw
var products = context.Products
                      .FromSqlRaw("SELECT * FROM Products WHERE Price > 100")
                      .ToList();

// Requête avec FromSqlInterpolated (permet l'utilisation de variables)
var minPrice = 100;
var products = context.Products
                      .FromSqlInterpolated($"SELECT * FROM Products WHERE Price > {minPrice}")
                      .ToList();
```

**Exemple : Exécution d'une commande SQL brute**
```csharp
context.Database.ExecuteSqlRaw("UPDATE Products SET Price = Price * 1.1 WHERE CategoryId = 1");
```

### 2. **Vues SQL**

Les vues en base de données peuvent être traitées comme des entités en Entity Framework. Vous devez simplement créer un modèle correspondant à la structure de la vue et le configurer pour qu'il soit traité comme une vue.

**Exemple : Mapping d'une vue SQL à une entité**
```csharp
public class SalesByCategory
{
    public string CategoryName { get; set; }
    public string ProductName { get; set; }
    public decimal TotalSales { get; set; }
}

public class AppDbContext : DbContext
{
    public DbSet<SalesByCategory> SalesByCategory { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder
            .Entity<SalesByCategory>()
            .HasNoKey()  // Les vues n'ont généralement pas de clé primaire
            .ToView("SalesByCategory"); // Nom de la vue dans la base de données
    }
}

// Utilisation
var sales = context.SalesByCategory.ToList();
```

### 3. **Procédures stockées**

Entity Framework permet également d'appeler des procédures stockées via `FromSqlRaw` ou `ExecuteSqlRaw`. Le résultat de la procédure peut être mappé à une entité ou un type spécifique.

**Exemple : Appel d'une procédure stockée qui retourne des données**
```csharp
// Supposons qu'il y ait une procédure stockée "GetProductsByCategory" qui prend un paramètre CategoryId
var categoryId = 1;
var products = context.Products
                      .FromSqlRaw("EXEC GetProductsByCategory @p0", categoryId)
                      .ToList();
```

**Exemple : Appel d'une procédure stockée qui ne retourne pas de données**
```csharp
// Supposons qu'il y ait une procédure stockée "UpdateProductPrice" qui met à jour les prix
context.Database.ExecuteSqlRaw("EXEC UpdateProductPrice @p0, @p1", productId, newPrice);
```

### 4. **Procédures stockées avec des paramètres de sortie**

Il est également possible d'utiliser des paramètres de sortie avec des procédures stockées.

**Exemple : Procédure stockée avec un paramètre de sortie**
```csharp
// Procédure stockée qui retourne le nombre total de produits dans une catégorie
var categoryId = 1;
var totalProductsParam = new SqlParameter
{
    ParameterName = "@TotalProducts",
    SqlDbType = SqlDbType.Int,
    Direction = ParameterDirection.Output
};

context.Database.ExecuteSqlRaw("EXEC GetTotalProductsByCategory @CategoryId, @TotalProducts OUT", 
                               new SqlParameter("@CategoryId", categoryId), 
                               totalProductsParam);

int totalProducts = (int)totalProductsParam.Value;
```

### Conclusion

- **Requêtes SQL brutes** : Utilisez `FromSqlRaw`, `FromSqlInterpolated` pour exécuter des requêtes SQL directement tout en continuant à bénéficier du mapping d'entités.
- **Vues SQL** : Traitez les vues comme des entités en définissant des modèles et en les mappant avec `ToView` dans `OnModelCreating`.
- **Procédures stockées** : Appelez des procédures stockées avec `FromSqlRaw` ou `ExecuteSqlRaw` et gérez les résultats comme vous le feriez avec des requêtes SQL brutes. Vous pouvez également gérer des paramètres de sortie.

Ces fonctionnalités permettent une flexibilité dans les interactions avec la base de données, en combinant les avantages d'Entity Framework avec la puissance des requêtes SQL traditionnelles.
