# Deploiement d'un simple service Web.Api consommant du Redis Cache (Docker et Docker Compose)

Voici une approche complète pour créer, configurer, et déployer un microservice de gestion de cache en utilisant .NET 8.0, Docker, et Docker Compose.

### Structure du Projet

La structure du projet sera la suivante :

```
/CacheService
    /Controllers
        CacheController.cs
    /Services
        ICacheService.cs
        RedisCacheService.cs
    Program.cs
    appsettings.json
    Dockerfile
    docker-compose.yml
```

### Code Source

#### `Program.cs`

Créez le fichier `Program.cs` avec le code suivant pour configurer et démarrer l'application :

```csharp
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using StackExchange.Redis;
using System;

var builder = WebApplication.CreateBuilder(args);

// Configure Redis connection
var redisConnectionString = builder.Configuration.GetConnectionString("Redis");
builder.Services.AddSingleton<IConnectionMultiplexer>(ConnectionMultiplexer.Connect(redisConnectionString));
builder.Services.AddSingleton<ICacheService, RedisCacheService>();

// Add services to the container.
builder.Services.AddControllers();

var app = builder.Build();

// Configure the HTTP request pipeline.
app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();

app.Run();
```

#### `appsettings.json`

Créez le fichier `appsettings.json` avec la configuration de connexion pour Redis :

```json
{
  "ConnectionStrings": {
    "Redis": "redis:6379" // Nom du service Redis défini dans docker-compose
  },
  "AllowedHosts": "*"
}
```

#### `Services/ICacheService.cs`

Créez l'interface `ICacheService` :

```csharp
public interface ICacheService
{
    Task SetCacheAsync(string key, string value, TimeSpan expiration);
    Task<string> GetCacheAsync(string key);
    Task RemoveCacheAsync(string key);
    Task ClearCacheAsync();
}
```

#### `Services/RedisCacheService.cs`

Créez la classe `RedisCacheService` qui implémente `ICacheService` :

```csharp
using StackExchange.Redis;
using System;
using System.Threading.Tasks;

public class RedisCacheService : ICacheService
{
    private readonly IDatabase _database;

    public RedisCacheService(IConnectionMultiplexer redis)
    {
        _database = redis.GetDatabase();
    }

    public async Task SetCacheAsync(string key, string value, TimeSpan expiration)
    {
        await _database.StringSetAsync(key, value, expiration);
    }

    public async Task<string> GetCacheAsync(string key)
    {
        return await _database.StringGetAsync(key);
    }

    public async Task RemoveCacheAsync(string key)
    {
        await _database.KeyDeleteAsync(key);
    }

    public async Task ClearCacheAsync()
    {
        var endpoints = _database.Multiplexer.GetEndPoints();
        foreach (var endpoint in endpoints)
        {
            var server = _database.Multiplexer.GetServer(endpoint);
            await server.FlushDatabaseAsync();
        }
    }
}
```

#### `Controllers/CacheController.cs`

Créez le contrôleur API pour gérer les opérations de cache :

```csharp
using Microsoft.AspNetCore.Mvc;
using System;
using System.Threading.Tasks;

[ApiController]
[Route("api/[controller]")]
public class CacheController : ControllerBase
{
    private readonly ICacheService _cacheService;

    public CacheController(ICacheService cacheService)
    {
        _cacheService = cacheService;
    }

    [HttpPost("set")]
    public async Task<IActionResult> SetCache([FromQuery] string key, [FromQuery] string value, [FromQuery] TimeSpan expiration)
    {
        await _cacheService.SetCacheAsync(key, value, expiration);
        return Ok();
    }

    [HttpGet("get")]
    public async Task<IActionResult> GetCache([FromQuery] string key)
    {
        var value = await _cacheService.GetCacheAsync(key);
        if (value == null) return NotFound();
        return Ok(value);
    }

    [HttpDelete("remove")]
    public async Task<IActionResult> RemoveCache([FromQuery] string key)
    {
        await _cacheService.RemoveCacheAsync(key);
        return NoContent();
    }

    [HttpDelete("clear")]
    public async Task<IActionResult> ClearCache()
    {
        await _cacheService.ClearCacheAsync();
        return NoContent();
    }
}
```

### Dockerfile

Créez le fichier `Dockerfile` à la racine de votre projet :

```dockerfile
# Utilisez l'image officielle .NET SDK comme image de base pour la construction
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build

# Définir le répertoire de travail dans le conteneur
WORKDIR /app

# Copier les fichiers csproj et restaurer les dépendances
COPY *.csproj ./
RUN dotnet restore

# Copier le reste du code source
COPY . ./

# Construire l'application
RUN dotnet publish -c Release -o out

# Utiliser l'image de runtime .NET pour exécuter l'application
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS runtime
WORKDIR /app
COPY --from=build /app/out .

# Exposer le port utilisé par l'application
EXPOSE 80

# Définir le point d'entrée de l'application
ENTRYPOINT ["dotnet", "CacheService.dll"]
```

### docker-compose.yml

Créez le fichier `docker-compose.yml` à la racine de votre projet pour déployer à la fois l'application et Redis :

```yaml
version: '3.8'

services:
  cache-service:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "5000:80"  # Map le port 5000 de l'hôte au port 80 du conteneur
    depends_on:
      - redis

  redis:
    image: redis:latest
    ports:
      - "6379:6379"  # Map le port 6379 de l'hôte au port 6379 du conteneur
```

### Déploiement

1. **Construisez et démarrez les services** :
   ```sh
   docker-compose up --build
   ```

2. **Vérifiez que les services sont en cours d'exécution** :
   ```sh
   docker-compose ps
   ```

Votre microservice de gestion de cache sera accessible via `http://localhost:5000`, et Redis sera disponible sur le port 6379. Vous pouvez utiliser ces points de terminaison pour tester votre service de cache en envoyant des requêtes HTTP à l'API.
